// This file was generated by ODB, object-relational mapping (ORM)
// compiler for C++.
//

#include <odb/pre.hxx>

#include "Schema-odb-sqlite.hxx"

#include <cassert>
#include <cstring>  // std::memcpy

#include <odb/schema-catalog-impl.hxx>

#include <odb/sqlite/traits.hxx>
#include <odb/sqlite/database.hxx>
#include <odb/sqlite/transaction.hxx>
#include <odb/sqlite/connection.hxx>
#include <odb/sqlite/statement.hxx>
#include <odb/sqlite/statement-cache.hxx>
#include <odb/sqlite/simple-object-statements.hxx>
#include <odb/sqlite/view-statements.hxx>
#include <odb/sqlite/container-statements.hxx>
#include <odb/sqlite/exceptions.hxx>
#include <odb/sqlite/simple-object-result.hxx>
#include <odb/sqlite/view-result.hxx>

namespace odb
{
  // Version
  //

  struct access::object_traits_impl< ::CoinDB::Version, id_sqlite >::extra_statement_cache_type
  {
    extra_statement_cache_type (
      sqlite::connection&,
      image_type&,
      sqlite::binding&,
      sqlite::binding&)
    {
    }
  };

  access::object_traits_impl< ::CoinDB::Version, id_sqlite >::id_type
  access::object_traits_impl< ::CoinDB::Version, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::CoinDB::Version, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id_
    //
    t[0UL] = false;

    // version_
    //
    t[1UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::Version, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // id_
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // version_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.version_value;
    b[n].is_null = &i.version_null;
    n++;
  }

  void access::object_traits_impl< ::CoinDB::Version, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::CoinDB::Version, id_sqlite >::
  init (image_type& i,
        const object_type& o,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // id_
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.id_;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        v);
      i.id_null = is_null;
    }

    // version_
    //
    {
      ::uint32_t const& v =
        o.version_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_image (
        i.version_value,
        is_null,
        v);
      i.version_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::Version, id_sqlite >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id_
    //
    {
      long unsigned int& v =
        o.id_;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // version_
    //
    {
      ::uint32_t& v =
        o.version_;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.version_value,
        i.version_null);
    }
  }

  void access::object_traits_impl< ::CoinDB::Version, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::CoinDB::Version, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Version\" "
  "(\"id\", "
  "\"version\") "
  "VALUES "
  "(?, ?)";

  const char access::object_traits_impl< ::CoinDB::Version, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Version\".\"id\", "
  "\"Version\".\"version\" "
  "FROM \"Version\" "
  "WHERE \"Version\".\"id\"=?";

  const char access::object_traits_impl< ::CoinDB::Version, id_sqlite >::update_statement[] =
  "UPDATE \"Version\" "
  "SET "
  "\"version\"=? "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::Version, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Version\" "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::Version, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Version\".\"id\", "
  "\"Version\".\"version\" "
  "FROM \"Version\"";

  const char access::object_traits_impl< ::CoinDB::Version, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Version\"";

  const char access::object_traits_impl< ::CoinDB::Version, id_sqlite >::table_name[] =
  "\"Version\"";

  void access::object_traits_impl< ::CoinDB::Version, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id_ = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::CoinDB::Version, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;
    using sqlite::update_statement;

    callback (db, obj, callback_event::pre_update);

    sqlite::transaction& tr (sqlite::transaction::current ());
    sqlite::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id_);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::CoinDB::Version, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::CoinDB::Version, id_sqlite >::pointer_type
  access::object_traits_impl< ::CoinDB::Version, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::CoinDB::Version, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::Version, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id_);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::Version, id_sqlite >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::CoinDB::Version, id_sqlite >::object_type >
  access::object_traits_impl< ::CoinDB::Version, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::CoinDB::Version, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // Network
  //

  struct access::object_traits_impl< ::CoinDB::Network, id_sqlite >::extra_statement_cache_type
  {
    extra_statement_cache_type (
      sqlite::connection&,
      image_type&,
      sqlite::binding&,
      sqlite::binding&)
    {
    }
  };

  access::object_traits_impl< ::CoinDB::Network, id_sqlite >::id_type
  access::object_traits_impl< ::CoinDB::Network, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::CoinDB::Network, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id_
    //
    t[0UL] = false;

    // network_
    //
    if (t[1UL])
    {
      i.network_value.capacity (i.network_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::Network, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // id_
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // network_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.network_value.data ();
    b[n].size = &i.network_size;
    b[n].capacity = i.network_value.capacity ();
    b[n].is_null = &i.network_null;
    n++;
  }

  void access::object_traits_impl< ::CoinDB::Network, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::CoinDB::Network, id_sqlite >::
  init (image_type& i,
        const object_type& o,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // id_
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.id_;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        v);
      i.id_null = is_null;
    }

    // network_
    //
    {
      ::std::string const& v =
        o.network_;

      bool is_null (false);
      std::size_t cap (i.network_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.network_value,
        i.network_size,
        is_null,
        v);
      i.network_null = is_null;
      grew = grew || (cap != i.network_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::Network, id_sqlite >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id_
    //
    {
      long unsigned int& v =
        o.id_;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // network_
    //
    {
      ::std::string& v =
        o.network_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.network_value,
        i.network_size,
        i.network_null);
    }
  }

  void access::object_traits_impl< ::CoinDB::Network, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::CoinDB::Network, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Network\" "
  "(\"id\", "
  "\"network\") "
  "VALUES "
  "(?, ?)";

  const char access::object_traits_impl< ::CoinDB::Network, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Network\".\"id\", "
  "\"Network\".\"network\" "
  "FROM \"Network\" "
  "WHERE \"Network\".\"id\"=?";

  const char access::object_traits_impl< ::CoinDB::Network, id_sqlite >::update_statement[] =
  "UPDATE \"Network\" "
  "SET "
  "\"network\"=? "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::Network, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Network\" "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::Network, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Network\".\"id\", "
  "\"Network\".\"network\" "
  "FROM \"Network\"";

  const char access::object_traits_impl< ::CoinDB::Network, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Network\"";

  const char access::object_traits_impl< ::CoinDB::Network, id_sqlite >::table_name[] =
  "\"Network\"";

  void access::object_traits_impl< ::CoinDB::Network, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id_ = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::CoinDB::Network, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;
    using sqlite::update_statement;

    callback (db, obj, callback_event::pre_update);

    sqlite::transaction& tr (sqlite::transaction::current ());
    sqlite::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id_);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::CoinDB::Network, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::CoinDB::Network, id_sqlite >::pointer_type
  access::object_traits_impl< ::CoinDB::Network, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::CoinDB::Network, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::Network, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id_);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::Network, id_sqlite >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::CoinDB::Network, id_sqlite >::object_type >
  access::object_traits_impl< ::CoinDB::Network, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::CoinDB::Network, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // User
  //

  struct access::object_traits_impl< ::CoinDB::User, id_sqlite >::extra_statement_cache_type
  {
    sqlite::container_statements_impl< txoutscript_whitelist_traits > txoutscript_whitelist_;

    extra_statement_cache_type (
      sqlite::connection& c,
      image_type&,
      sqlite::binding& id,
      sqlite::binding&)
    : txoutscript_whitelist_ (c, id)
    {
    }
  };

  // txoutscript_whitelist_
  //

  const char access::object_traits_impl< ::CoinDB::User, id_sqlite >::txoutscript_whitelist_traits::
  select_statement[] =
  "SELECT "
  "\"User_txoutscript_whitelist\".\"value\" "
  "FROM \"User_txoutscript_whitelist\" "
  "WHERE \"User_txoutscript_whitelist\".\"object_id\"=?";

  const char access::object_traits_impl< ::CoinDB::User, id_sqlite >::txoutscript_whitelist_traits::
  insert_statement[] =
  "INSERT INTO \"User_txoutscript_whitelist\" "
  "(\"object_id\", "
  "\"value\") "
  "VALUES "
  "(?, ?)";

  const char access::object_traits_impl< ::CoinDB::User, id_sqlite >::txoutscript_whitelist_traits::
  delete_statement[] =
  "DELETE FROM \"User_txoutscript_whitelist\" "
  "WHERE \"object_id\"=?";

  void access::object_traits_impl< ::CoinDB::User, id_sqlite >::txoutscript_whitelist_traits::
  bind (sqlite::bind* b,
        const sqlite::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace sqlite;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // value
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = d.value_value.data ();
    b[n].size = &d.value_size;
    b[n].capacity = d.value_value.capacity ();
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::CoinDB::User, id_sqlite >::txoutscript_whitelist_traits::
  grow (data_image_type& i,
        bool* t)
  {
    bool grew (false);

    // value
    //
    if (t[0UL])
    {
      i.value_value.capacity (i.value_size);
      grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::CoinDB::User, id_sqlite >::txoutscript_whitelist_traits::
  init (data_image_type& i,
        const value_type& v)
  {
    using namespace sqlite;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // value
    //
    {
      bool is_null (false);
      std::size_t cap (i.value_value.capacity ());
      sqlite::value_traits<
          value_type,
          sqlite::id_blob >::set_image (
        i.value_value,
        i.value_size,
        is_null,
        v);
      i.value_null = is_null;
      grew = grew || (cap != i.value_value.capacity ());
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::CoinDB::User, id_sqlite >::txoutscript_whitelist_traits::
  init (value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // value
    //
    {
      sqlite::value_traits<
          value_type,
          sqlite::id_blob >::set_value (
        v,
        i.value_value,
        i.value_size,
        i.value_null);
    }
  }

  void access::object_traits_impl< ::CoinDB::User, id_sqlite >::txoutscript_whitelist_traits::
  insert (const value_type& v, void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::CoinDB::User, id_sqlite >::txoutscript_whitelist_traits::
  select (value_type& v, void* d)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::CoinDB::User, id_sqlite >::txoutscript_whitelist_traits::
  delete_ (void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::CoinDB::User, id_sqlite >::txoutscript_whitelist_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::CoinDB::User, id_sqlite >::txoutscript_whitelist_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::CoinDB::User, id_sqlite >::txoutscript_whitelist_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::CoinDB::User, id_sqlite >::txoutscript_whitelist_traits::
  erase (statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    container_traits_type::erase (fs);
  }

  access::object_traits_impl< ::CoinDB::User, id_sqlite >::id_type
  access::object_traits_impl< ::CoinDB::User, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::CoinDB::User, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id_
    //
    t[0UL] = false;

    // username_
    //
    if (t[1UL])
    {
      i.username_value.capacity (i.username_size);
      grew = true;
    }

    // txoutscript_whitelist_enabled_
    //
    t[2UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::User, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // id_
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // username_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.username_value.data ();
    b[n].size = &i.username_size;
    b[n].capacity = i.username_value.capacity ();
    b[n].is_null = &i.username_null;
    n++;

    // txoutscript_whitelist_enabled_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.txoutscript_whitelist_enabled_value;
    b[n].is_null = &i.txoutscript_whitelist_enabled_null;
    n++;
  }

  void access::object_traits_impl< ::CoinDB::User, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::CoinDB::User, id_sqlite >::
  init (image_type& i,
        const object_type& o,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // id_
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.id_;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        v);
      i.id_null = is_null;
    }

    // username_
    //
    {
      ::std::string const& v =
        o.username_;

      bool is_null (false);
      std::size_t cap (i.username_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.username_value,
        i.username_size,
        is_null,
        v);
      i.username_null = is_null;
      grew = grew || (cap != i.username_value.capacity ());
    }

    // txoutscript_whitelist_enabled_
    //
    {
      bool const& v =
        o.txoutscript_whitelist_enabled_;

      bool is_null (false);
      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_image (
        i.txoutscript_whitelist_enabled_value,
        is_null,
        v);
      i.txoutscript_whitelist_enabled_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::User, id_sqlite >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id_
    //
    {
      long unsigned int& v =
        o.id_;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // username_
    //
    {
      ::std::string& v =
        o.username_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.username_value,
        i.username_size,
        i.username_null);
    }

    // txoutscript_whitelist_enabled_
    //
    {
      bool& v =
        o.txoutscript_whitelist_enabled_;

      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_value (
        v,
        i.txoutscript_whitelist_enabled_value,
        i.txoutscript_whitelist_enabled_null);
    }
  }

  void access::object_traits_impl< ::CoinDB::User, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::CoinDB::User, id_sqlite >::persist_statement[] =
  "INSERT INTO \"User\" "
  "(\"id\", "
  "\"username\", "
  "\"txoutscript_whitelist_enabled\") "
  "VALUES "
  "(?, ?, ?)";

  const char access::object_traits_impl< ::CoinDB::User, id_sqlite >::find_statement[] =
  "SELECT "
  "\"User\".\"id\", "
  "\"User\".\"username\", "
  "\"User\".\"txoutscript_whitelist_enabled\" "
  "FROM \"User\" "
  "WHERE \"User\".\"id\"=?";

  const char access::object_traits_impl< ::CoinDB::User, id_sqlite >::update_statement[] =
  "UPDATE \"User\" "
  "SET "
  "\"username\"=?, "
  "\"txoutscript_whitelist_enabled\"=? "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::User, id_sqlite >::erase_statement[] =
  "DELETE FROM \"User\" "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::User, id_sqlite >::query_statement[] =
  "SELECT "
  "\"User\".\"id\", "
  "\"User\".\"username\", "
  "\"User\".\"txoutscript_whitelist_enabled\" "
  "FROM \"User\"";

  const char access::object_traits_impl< ::CoinDB::User, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"User\"";

  const char access::object_traits_impl< ::CoinDB::User, id_sqlite >::table_name[] =
  "\"User\"";

  void access::object_traits_impl< ::CoinDB::User, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id_ = static_cast< id_type > (st.id ());

    id_image_type& i (sts.id_image ());
    init (i, obj.id_);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // txoutscript_whitelist_
    //
    {
      ::std::set< ::std::vector< unsigned char > > const& v =
        obj.txoutscript_whitelist_;

      txoutscript_whitelist_traits::persist (
        v,
        esc.txoutscript_whitelist_);
    }

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::CoinDB::User, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;
    using sqlite::update_statement;

    callback (db, obj, callback_event::pre_update);

    sqlite::transaction& tr (sqlite::transaction::current ());
    sqlite::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id_);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // txoutscript_whitelist_
    //
    {
      ::std::set< ::std::vector< unsigned char > > const& v =
        obj.txoutscript_whitelist_;

      txoutscript_whitelist_traits::update (
        v,
        esc.txoutscript_whitelist_);
    }

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::CoinDB::User, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // txoutscript_whitelist_
    //
    txoutscript_whitelist_traits::erase (
      esc.txoutscript_whitelist_);

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::CoinDB::User, id_sqlite >::pointer_type
  access::object_traits_impl< ::CoinDB::User, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::CoinDB::User, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::User, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id_);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::User, id_sqlite >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::CoinDB::User, id_sqlite >::
  load_ (statements_type& sts,
         object_type& obj,
         bool reload)
  {
    ODB_POTENTIALLY_UNUSED (reload);

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // txoutscript_whitelist_
    //
    {
      ::std::set< ::std::vector< unsigned char > >& v =
        obj.txoutscript_whitelist_;

      txoutscript_whitelist_traits::load (
        v,
        esc.txoutscript_whitelist_);
    }
  }

  result< access::object_traits_impl< ::CoinDB::User, id_sqlite >::object_type >
  access::object_traits_impl< ::CoinDB::User, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::CoinDB::User, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // Contact
  //

  struct access::object_traits_impl< ::CoinDB::Contact, id_sqlite >::extra_statement_cache_type
  {
    extra_statement_cache_type (
      sqlite::connection&,
      image_type&,
      sqlite::binding&,
      sqlite::binding&)
    {
    }
  };

  access::object_traits_impl< ::CoinDB::Contact, id_sqlite >::id_type
  access::object_traits_impl< ::CoinDB::Contact, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::CoinDB::Contact, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id_
    //
    t[0UL] = false;

    // username_
    //
    if (t[1UL])
    {
      i.username_value.capacity (i.username_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::Contact, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // id_
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // username_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.username_value.data ();
    b[n].size = &i.username_size;
    b[n].capacity = i.username_value.capacity ();
    b[n].is_null = &i.username_null;
    n++;
  }

  void access::object_traits_impl< ::CoinDB::Contact, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::CoinDB::Contact, id_sqlite >::
  init (image_type& i,
        const object_type& o,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // id_
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.id_;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        v);
      i.id_null = is_null;
    }

    // username_
    //
    {
      ::std::string const& v =
        o.username_;

      bool is_null (false);
      std::size_t cap (i.username_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.username_value,
        i.username_size,
        is_null,
        v);
      i.username_null = is_null;
      grew = grew || (cap != i.username_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::Contact, id_sqlite >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id_
    //
    {
      long unsigned int& v =
        o.id_;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // username_
    //
    {
      ::std::string& v =
        o.username_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.username_value,
        i.username_size,
        i.username_null);
    }
  }

  void access::object_traits_impl< ::CoinDB::Contact, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::CoinDB::Contact, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Contact\" "
  "(\"id\", "
  "\"username\") "
  "VALUES "
  "(?, ?)";

  const char access::object_traits_impl< ::CoinDB::Contact, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Contact\".\"id\", "
  "\"Contact\".\"username\" "
  "FROM \"Contact\" "
  "WHERE \"Contact\".\"id\"=?";

  const char access::object_traits_impl< ::CoinDB::Contact, id_sqlite >::update_statement[] =
  "UPDATE \"Contact\" "
  "SET "
  "\"username\"=? "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::Contact, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Contact\" "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::Contact, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Contact\".\"id\", "
  "\"Contact\".\"username\" "
  "FROM \"Contact\"";

  const char access::object_traits_impl< ::CoinDB::Contact, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Contact\"";

  const char access::object_traits_impl< ::CoinDB::Contact, id_sqlite >::table_name[] =
  "\"Contact\"";

  void access::object_traits_impl< ::CoinDB::Contact, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id_ = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::CoinDB::Contact, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;
    using sqlite::update_statement;

    callback (db, obj, callback_event::pre_update);

    sqlite::transaction& tr (sqlite::transaction::current ());
    sqlite::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id_);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::CoinDB::Contact, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::CoinDB::Contact, id_sqlite >::pointer_type
  access::object_traits_impl< ::CoinDB::Contact, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::CoinDB::Contact, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::Contact, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id_);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::Contact, id_sqlite >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::CoinDB::Contact, id_sqlite >::object_type >
  access::object_traits_impl< ::CoinDB::Contact, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::CoinDB::Contact, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // Keychain
  //

  const char alias_traits<  ::CoinDB::Keychain,
    id_sqlite,
    access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::parent_tag>::
  table_name[] = "\"parent\"";

  struct access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::extra_statement_cache_type
  {
    sqlite::container_statements_impl< derivation_path_traits > derivation_path_;
    sqlite::container_statements_impl< children_traits > children_;

    extra_statement_cache_type (
      sqlite::connection& c,
      image_type&,
      sqlite::binding& id,
      sqlite::binding&)
    : derivation_path_ (c, id),
      children_ (c, id)
    {
    }
  };

  // derivation_path_
  //

  const char access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::derivation_path_traits::
  select_statement[] =
  "SELECT "
  "\"Keychain_derivation_path\".\"index\", "
  "\"Keychain_derivation_path\".\"value\" "
  "FROM \"Keychain_derivation_path\" "
  "WHERE \"Keychain_derivation_path\".\"object_id\"=? ORDER BY \"Keychain_derivation_path\".\"index\"";

  const char access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::derivation_path_traits::
  insert_statement[] =
  "INSERT INTO \"Keychain_derivation_path\" "
  "(\"object_id\", "
  "\"index\", "
  "\"value\") "
  "VALUES "
  "(?, ?, ?)";

  const char access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::derivation_path_traits::
  delete_statement[] =
  "DELETE FROM \"Keychain_derivation_path\" "
  "WHERE \"object_id\"=?";

  void access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::derivation_path_traits::
  bind (sqlite::bind* b,
        const sqlite::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace sqlite;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // index
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &d.index_value;
    b[n].is_null = &d.index_null;
    n++;

    // value
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &d.value_value;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::derivation_path_traits::
  grow (data_image_type& i,
        bool* t)
  {
    bool grew (false);

    // index
    //
    t[0UL] = false;

    // value
    //
    t[1UL] = false;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::derivation_path_traits::
  init (data_image_type& i,
        index_type* j,
        const value_type& v)
  {
    using namespace sqlite;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // index
    //
    if (j != 0)
    {
      bool is_null (false);
      sqlite::value_traits<
          index_type,
          sqlite::id_integer >::set_image (
        i.index_value,
        is_null,
        *j);
      i.index_null = is_null;
    }

    // value
    //
    {
      bool is_null (false);
      sqlite::value_traits<
          value_type,
          sqlite::id_integer >::set_image (
        i.value_value,
        is_null,
        v);
      i.value_null = is_null;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::derivation_path_traits::
  init (index_type& j,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // index
    //
    {
      sqlite::value_traits<
          index_type,
          sqlite::id_integer >::set_value (
        j,
        i.index_value,
        i.index_null);
    }

    // value
    //
    {
      sqlite::value_traits<
          value_type,
          sqlite::id_integer >::set_value (
        v,
        i.value_value,
        i.value_null);
    }
  }

  void access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::derivation_path_traits::
  insert (index_type i, const value_type& v, void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &i, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::derivation_path_traits::
  select (index_type& i, value_type& v, void* d)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (i, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());
    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::derivation_path_traits::
  delete_ (void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::derivation_path_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::derivation_path_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());
    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::derivation_path_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::derivation_path_traits::
  erase (statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::erase (fs);
  }

  // children_
  //

  const char access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::children_traits::
  select_statement[] =
  "SELECT "
  "\"Keychain\".\"id\" "
  "FROM \"Keychain\" "
  "WHERE \"Keychain\".\"parent\"=?";

  const char access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::children_traits::
  insert_statement[] =
  "";

  const char access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::children_traits::
  delete_statement[] =
  "";

  void access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::children_traits::
  bind (sqlite::bind* b,
        const sqlite::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace sqlite;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // value
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &d.value_value;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::children_traits::
  grow (data_image_type& i,
        bool* t)
  {
    bool grew (false);

    // value
    //
    t[0UL] = false;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::children_traits::
  init (value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // value
    //
    {
      typedef object_traits< ::CoinDB::Keychain > obj_traits;
      typedef odb::pointer_traits< value_type > ptr_traits;

      if (i.value_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.value_value,
          i.value_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));

        if (odb::pointer_traits<ptr_traits::strong_pointer_type>::null_ptr (
              ptr_traits::lock (v)))
          throw session_required ();
      }
    }
  }

  void access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::children_traits::
  insert (index_type, const value_type&, void*)
  {
  }

  bool access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::children_traits::
  select (index_type&, value_type& v, void* d)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (v, di, &sts.connection ().database ());

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());
    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::children_traits::
  delete_ (void*)
  {
  }

  void access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::children_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());
    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = false;
    container_traits_type::load (c, more, fs);
  }

  access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::id_type
  access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id_
    //
    t[0UL] = false;

    // name_
    //
    if (t[1UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // depth_
    //
    t[2UL] = false;

    // parent_fp_
    //
    t[3UL] = false;

    // child_num_
    //
    t[4UL] = false;

    // pubkey_
    //
    if (t[5UL])
    {
      i.pubkey_value.capacity (i.pubkey_size);
      grew = true;
    }

    // chain_code_
    //
    if (t[6UL])
    {
      i.chain_code_value.capacity (i.chain_code_size);
      grew = true;
    }

    // privkey_ciphertext_
    //
    if (t[7UL])
    {
      i.privkey_ciphertext_value.capacity (i.privkey_ciphertext_size);
      grew = true;
    }

    // privkey_salt_
    //
    t[8UL] = false;

    // seed_ciphertext_
    //
    if (t[9UL])
    {
      i.seed_ciphertext_value.capacity (i.seed_ciphertext_size);
      grew = true;
    }

    // seed_salt_
    //
    t[10UL] = false;

    // parent_
    //
    t[11UL] = false;

    // hash_
    //
    if (t[12UL])
    {
      i.hash_value.capacity (i.hash_size);
      grew = true;
    }

    // hidden_
    //
    t[13UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // id_
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // name_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.name_value.data ();
    b[n].size = &i.name_size;
    b[n].capacity = i.name_value.capacity ();
    b[n].is_null = &i.name_null;
    n++;

    // depth_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.depth_value;
    b[n].is_null = &i.depth_null;
    n++;

    // parent_fp_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.parent_fp_value;
    b[n].is_null = &i.parent_fp_null;
    n++;

    // child_num_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.child_num_value;
    b[n].is_null = &i.child_num_null;
    n++;

    // pubkey_
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.pubkey_value.data ();
    b[n].size = &i.pubkey_size;
    b[n].capacity = i.pubkey_value.capacity ();
    b[n].is_null = &i.pubkey_null;
    n++;

    // chain_code_
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.chain_code_value.data ();
    b[n].size = &i.chain_code_size;
    b[n].capacity = i.chain_code_value.capacity ();
    b[n].is_null = &i.chain_code_null;
    n++;

    // privkey_ciphertext_
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.privkey_ciphertext_value.data ();
    b[n].size = &i.privkey_ciphertext_size;
    b[n].capacity = i.privkey_ciphertext_value.capacity ();
    b[n].is_null = &i.privkey_ciphertext_null;
    n++;

    // privkey_salt_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.privkey_salt_value;
    b[n].is_null = &i.privkey_salt_null;
    n++;

    // seed_ciphertext_
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.seed_ciphertext_value.data ();
    b[n].size = &i.seed_ciphertext_size;
    b[n].capacity = i.seed_ciphertext_value.capacity ();
    b[n].is_null = &i.seed_ciphertext_null;
    n++;

    // seed_salt_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.seed_salt_value;
    b[n].is_null = &i.seed_salt_null;
    n++;

    // parent_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.parent_value;
    b[n].is_null = &i.parent_null;
    n++;

    // hash_
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.hash_value.data ();
    b[n].size = &i.hash_size;
    b[n].capacity = i.hash_value.capacity ();
    b[n].is_null = &i.hash_null;
    n++;

    // hidden_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.hidden_value;
    b[n].is_null = &i.hidden_null;
    n++;
  }

  void access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::
  init (image_type& i,
        const object_type& o,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // id_
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.id_;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        v);
      i.id_null = is_null;
    }

    // name_
    //
    {
      ::std::string const& v =
        o.name_;

      bool is_null (false);
      std::size_t cap (i.name_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.name_value,
        i.name_size,
        is_null,
        v);
      i.name_null = is_null;
      grew = grew || (cap != i.name_value.capacity ());
    }

    // depth_
    //
    {
      ::uint32_t const& v =
        o.depth_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_image (
        i.depth_value,
        is_null,
        v);
      i.depth_null = is_null;
    }

    // parent_fp_
    //
    {
      ::uint32_t const& v =
        o.parent_fp_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_image (
        i.parent_fp_value,
        is_null,
        v);
      i.parent_fp_null = is_null;
    }

    // child_num_
    //
    {
      ::uint32_t const& v =
        o.child_num_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_image (
        i.child_num_value,
        is_null,
        v);
      i.child_num_null = is_null;
    }

    // pubkey_
    //
    {
      ::bytes_t const& v =
        o.pubkey_;

      bool is_null (false);
      std::size_t cap (i.pubkey_value.capacity ());
      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_image (
        i.pubkey_value,
        i.pubkey_size,
        is_null,
        v);
      i.pubkey_null = is_null;
      grew = grew || (cap != i.pubkey_value.capacity ());
    }

    // chain_code_
    //
    {
      ::bytes_t const& v =
        o.chain_code_;

      bool is_null (false);
      std::size_t cap (i.chain_code_value.capacity ());
      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_image (
        i.chain_code_value,
        i.chain_code_size,
        is_null,
        v);
      i.chain_code_null = is_null;
      grew = grew || (cap != i.chain_code_value.capacity ());
    }

    // privkey_ciphertext_
    //
    {
      ::bytes_t const& v =
        o.privkey_ciphertext_;

      bool is_null (false);
      std::size_t cap (i.privkey_ciphertext_value.capacity ());
      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_image (
        i.privkey_ciphertext_value,
        i.privkey_ciphertext_size,
        is_null,
        v);
      i.privkey_ciphertext_null = is_null;
      grew = grew || (cap != i.privkey_ciphertext_value.capacity ());
    }

    // privkey_salt_
    //
    {
      ::uint64_t const& v =
        o.privkey_salt_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint64_t,
          sqlite::id_integer >::set_image (
        i.privkey_salt_value,
        is_null,
        v);
      i.privkey_salt_null = is_null;
    }

    // seed_ciphertext_
    //
    {
      ::bytes_t const& v =
        o.seed_ciphertext_;

      bool is_null (false);
      std::size_t cap (i.seed_ciphertext_value.capacity ());
      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_image (
        i.seed_ciphertext_value,
        i.seed_ciphertext_size,
        is_null,
        v);
      i.seed_ciphertext_null = is_null;
      grew = grew || (cap != i.seed_ciphertext_value.capacity ());
    }

    // seed_salt_
    //
    {
      ::uint64_t const& v =
        o.seed_salt_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint64_t,
          sqlite::id_integer >::set_image (
        i.seed_salt_value,
        is_null,
        v);
      i.seed_salt_null = is_null;
    }

    // parent_
    //
    {
      ::std::shared_ptr< ::CoinDB::Keychain > const& v =
        o.parent_;

      typedef object_traits< ::CoinDB::Keychain > obj_traits;
      typedef odb::pointer_traits< ::std::shared_ptr< ::CoinDB::Keychain > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.parent_value,
          is_null,
          id);
        i.parent_null = is_null;
      }
      else
        i.parent_null = true;
    }

    // hash_
    //
    {
      ::bytes_t const& v =
        o.hash_;

      bool is_null (false);
      std::size_t cap (i.hash_value.capacity ());
      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_image (
        i.hash_value,
        i.hash_size,
        is_null,
        v);
      i.hash_null = is_null;
      grew = grew || (cap != i.hash_value.capacity ());
    }

    // hidden_
    //
    {
      bool const& v =
        o.hidden_;

      bool is_null (false);
      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_image (
        i.hidden_value,
        is_null,
        v);
      i.hidden_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id_
    //
    {
      long unsigned int& v =
        o.id_;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // name_
    //
    {
      ::std::string& v =
        o.name_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // depth_
    //
    {
      ::uint32_t& v =
        o.depth_;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.depth_value,
        i.depth_null);
    }

    // parent_fp_
    //
    {
      ::uint32_t& v =
        o.parent_fp_;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.parent_fp_value,
        i.parent_fp_null);
    }

    // child_num_
    //
    {
      ::uint32_t& v =
        o.child_num_;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.child_num_value,
        i.child_num_null);
    }

    // pubkey_
    //
    {
      ::bytes_t& v =
        o.pubkey_;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.pubkey_value,
        i.pubkey_size,
        i.pubkey_null);
    }

    // chain_code_
    //
    {
      ::bytes_t& v =
        o.chain_code_;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.chain_code_value,
        i.chain_code_size,
        i.chain_code_null);
    }

    // privkey_ciphertext_
    //
    {
      ::bytes_t& v =
        o.privkey_ciphertext_;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.privkey_ciphertext_value,
        i.privkey_ciphertext_size,
        i.privkey_ciphertext_null);
    }

    // privkey_salt_
    //
    {
      ::uint64_t& v =
        o.privkey_salt_;

      sqlite::value_traits<
          ::uint64_t,
          sqlite::id_integer >::set_value (
        v,
        i.privkey_salt_value,
        i.privkey_salt_null);
    }

    // seed_ciphertext_
    //
    {
      ::bytes_t& v =
        o.seed_ciphertext_;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.seed_ciphertext_value,
        i.seed_ciphertext_size,
        i.seed_ciphertext_null);
    }

    // seed_salt_
    //
    {
      ::uint64_t& v =
        o.seed_salt_;

      sqlite::value_traits<
          ::uint64_t,
          sqlite::id_integer >::set_value (
        v,
        i.seed_salt_value,
        i.seed_salt_null);
    }

    // parent_
    //
    {
      ::std::shared_ptr< ::CoinDB::Keychain >& v =
        o.parent_;

      typedef object_traits< ::CoinDB::Keychain > obj_traits;
      typedef odb::pointer_traits< ::std::shared_ptr< ::CoinDB::Keychain > > ptr_traits;

      if (i.parent_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.parent_value,
          i.parent_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // hash_
    //
    {
      ::bytes_t& v =
        o.hash_;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.hash_value,
        i.hash_size,
        i.hash_null);
    }

    // hidden_
    //
    {
      bool& v =
        o.hidden_;

      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_value (
        v,
        i.hidden_value,
        i.hidden_null);
    }
  }

  void access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Keychain\" "
  "(\"id\", "
  "\"name\", "
  "\"depth\", "
  "\"parent_fp\", "
  "\"child_num\", "
  "\"pubkey\", "
  "\"chain_code\", "
  "\"privkey_ciphertext\", "
  "\"privkey_salt\", "
  "\"seed_ciphertext\", "
  "\"seed_salt\", "
  "\"parent\", "
  "\"hash\", "
  "\"hidden\") "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Keychain\".\"id\", "
  "\"Keychain\".\"name\", "
  "\"Keychain\".\"depth\", "
  "\"Keychain\".\"parent_fp\", "
  "\"Keychain\".\"child_num\", "
  "\"Keychain\".\"pubkey\", "
  "\"Keychain\".\"chain_code\", "
  "\"Keychain\".\"privkey_ciphertext\", "
  "\"Keychain\".\"privkey_salt\", "
  "\"Keychain\".\"seed_ciphertext\", "
  "\"Keychain\".\"seed_salt\", "
  "\"Keychain\".\"parent\", "
  "\"Keychain\".\"hash\", "
  "\"Keychain\".\"hidden\" "
  "FROM \"Keychain\" "
  "WHERE \"Keychain\".\"id\"=?";

  const char access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::update_statement[] =
  "UPDATE \"Keychain\" "
  "SET "
  "\"name\"=?, "
  "\"depth\"=?, "
  "\"parent_fp\"=?, "
  "\"child_num\"=?, "
  "\"pubkey\"=?, "
  "\"chain_code\"=?, "
  "\"privkey_ciphertext\"=?, "
  "\"privkey_salt\"=?, "
  "\"seed_ciphertext\"=?, "
  "\"seed_salt\"=?, "
  "\"parent\"=?, "
  "\"hash\"=?, "
  "\"hidden\"=? "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Keychain\" "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::query_statement[] =
  "SELECT\n"
  "\"Keychain\".\"id\",\n"
  "\"Keychain\".\"name\",\n"
  "\"Keychain\".\"depth\",\n"
  "\"Keychain\".\"parent_fp\",\n"
  "\"Keychain\".\"child_num\",\n"
  "\"Keychain\".\"pubkey\",\n"
  "\"Keychain\".\"chain_code\",\n"
  "\"Keychain\".\"privkey_ciphertext\",\n"
  "\"Keychain\".\"privkey_salt\",\n"
  "\"Keychain\".\"seed_ciphertext\",\n"
  "\"Keychain\".\"seed_salt\",\n"
  "\"Keychain\".\"parent\",\n"
  "\"Keychain\".\"hash\",\n"
  "\"Keychain\".\"hidden\"\n"
  "FROM \"Keychain\"\n"
  "LEFT JOIN \"Keychain\" AS \"parent\" ON \"parent\".\"id\"=\"Keychain\".\"parent\"";

  const char access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Keychain\"";

  const char access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::table_name[] =
  "\"Keychain\"";

  void access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id_ = static_cast< id_type > (st.id ());

    id_image_type& i (sts.id_image ());
    init (i, obj.id_);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // derivation_path_
    //
    {
      ::std::vector< unsigned int > const& v =
        obj.derivation_path_;

      derivation_path_traits::persist (
        v,
        esc.derivation_path_);
    }

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;
    using sqlite::update_statement;

    callback (db, obj, callback_event::pre_update);

    sqlite::transaction& tr (sqlite::transaction::current ());
    sqlite::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id_);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // derivation_path_
    //
    {
      ::std::vector< unsigned int > const& v =
        obj.derivation_path_;

      derivation_path_traits::update (
        v,
        esc.derivation_path_);
    }

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // derivation_path_
    //
    derivation_path_traits::erase (
      esc.derivation_path_);

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::pointer_type
  access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id_);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::
  load_ (statements_type& sts,
         object_type& obj,
         bool reload)
  {
    ODB_POTENTIALLY_UNUSED (reload);

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // derivation_path_
    //
    {
      ::std::vector< unsigned int >& v =
        obj.derivation_path_;

      derivation_path_traits::load (
        v,
        esc.derivation_path_);
    }

    // children_
    //
    {
      ::std::vector< ::std::weak_ptr< ::CoinDB::Keychain > >& v =
        obj.children_;

      children_traits::load (
        v,
        esc.children_);
    }
  }

  result< access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::object_type >
  access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += "\n";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        true,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::CoinDB::Keychain, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // Key
  //

  const char alias_traits<  ::CoinDB::Keychain,
    id_sqlite,
    access::object_traits_impl< ::CoinDB::Key, id_sqlite >::root_keychain_tag>::
  table_name[] = "\"root_keychain\"";

  struct access::object_traits_impl< ::CoinDB::Key, id_sqlite >::extra_statement_cache_type
  {
    sqlite::container_statements_impl< derivation_path_traits > derivation_path_;

    extra_statement_cache_type (
      sqlite::connection& c,
      image_type&,
      sqlite::binding& id,
      sqlite::binding&)
    : derivation_path_ (c, id)
    {
    }
  };

  // derivation_path_
  //

  const char access::object_traits_impl< ::CoinDB::Key, id_sqlite >::derivation_path_traits::
  select_statement[] =
  "SELECT "
  "\"Key_derivation_path\".\"index\", "
  "\"Key_derivation_path\".\"value\" "
  "FROM \"Key_derivation_path\" "
  "WHERE \"Key_derivation_path\".\"object_id\"=? ORDER BY \"Key_derivation_path\".\"index\"";

  const char access::object_traits_impl< ::CoinDB::Key, id_sqlite >::derivation_path_traits::
  insert_statement[] =
  "INSERT INTO \"Key_derivation_path\" "
  "(\"object_id\", "
  "\"index\", "
  "\"value\") "
  "VALUES "
  "(?, ?, ?)";

  const char access::object_traits_impl< ::CoinDB::Key, id_sqlite >::derivation_path_traits::
  delete_statement[] =
  "DELETE FROM \"Key_derivation_path\" "
  "WHERE \"object_id\"=?";

  void access::object_traits_impl< ::CoinDB::Key, id_sqlite >::derivation_path_traits::
  bind (sqlite::bind* b,
        const sqlite::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace sqlite;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // index
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &d.index_value;
    b[n].is_null = &d.index_null;
    n++;

    // value
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &d.value_value;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::CoinDB::Key, id_sqlite >::derivation_path_traits::
  grow (data_image_type& i,
        bool* t)
  {
    bool grew (false);

    // index
    //
    t[0UL] = false;

    // value
    //
    t[1UL] = false;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::CoinDB::Key, id_sqlite >::derivation_path_traits::
  init (data_image_type& i,
        index_type* j,
        const value_type& v)
  {
    using namespace sqlite;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // index
    //
    if (j != 0)
    {
      bool is_null (false);
      sqlite::value_traits<
          index_type,
          sqlite::id_integer >::set_image (
        i.index_value,
        is_null,
        *j);
      i.index_null = is_null;
    }

    // value
    //
    {
      bool is_null (false);
      sqlite::value_traits<
          value_type,
          sqlite::id_integer >::set_image (
        i.value_value,
        is_null,
        v);
      i.value_null = is_null;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::CoinDB::Key, id_sqlite >::derivation_path_traits::
  init (index_type& j,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // index
    //
    {
      sqlite::value_traits<
          index_type,
          sqlite::id_integer >::set_value (
        j,
        i.index_value,
        i.index_null);
    }

    // value
    //
    {
      sqlite::value_traits<
          value_type,
          sqlite::id_integer >::set_value (
        v,
        i.value_value,
        i.value_null);
    }
  }

  void access::object_traits_impl< ::CoinDB::Key, id_sqlite >::derivation_path_traits::
  insert (index_type i, const value_type& v, void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &i, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::CoinDB::Key, id_sqlite >::derivation_path_traits::
  select (index_type& i, value_type& v, void* d)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (i, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());
    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::CoinDB::Key, id_sqlite >::derivation_path_traits::
  delete_ (void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::CoinDB::Key, id_sqlite >::derivation_path_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::CoinDB::Key, id_sqlite >::derivation_path_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());
    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::CoinDB::Key, id_sqlite >::derivation_path_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::CoinDB::Key, id_sqlite >::derivation_path_traits::
  erase (statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::erase (fs);
  }

  access::object_traits_impl< ::CoinDB::Key, id_sqlite >::id_type
  access::object_traits_impl< ::CoinDB::Key, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::CoinDB::Key, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id_
    //
    t[0UL] = false;

    // root_keychain_
    //
    t[1UL] = false;

    // index_
    //
    t[2UL] = false;

    // pubkey_
    //
    if (t[3UL])
    {
      i.pubkey_value.capacity (i.pubkey_size);
      grew = true;
    }

    // is_private_
    //
    t[4UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::Key, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // id_
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // root_keychain_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.root_keychain_value;
    b[n].is_null = &i.root_keychain_null;
    n++;

    // index_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.index_value;
    b[n].is_null = &i.index_null;
    n++;

    // pubkey_
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.pubkey_value.data ();
    b[n].size = &i.pubkey_size;
    b[n].capacity = i.pubkey_value.capacity ();
    b[n].is_null = &i.pubkey_null;
    n++;

    // is_private_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.is_private_value;
    b[n].is_null = &i.is_private_null;
    n++;
  }

  void access::object_traits_impl< ::CoinDB::Key, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::CoinDB::Key, id_sqlite >::
  init (image_type& i,
        const object_type& o,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // id_
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.id_;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        v);
      i.id_null = is_null;
    }

    // root_keychain_
    //
    {
      ::std::shared_ptr< ::CoinDB::Keychain > const& v =
        o.root_keychain_;

      typedef object_traits< ::CoinDB::Keychain > obj_traits;
      typedef odb::pointer_traits< ::std::shared_ptr< ::CoinDB::Keychain > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.root_keychain_value,
          is_null,
          id);
        i.root_keychain_null = is_null;
      }
      else
        i.root_keychain_null = true;
    }

    // index_
    //
    {
      ::uint32_t const& v =
        o.index_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_image (
        i.index_value,
        is_null,
        v);
      i.index_null = is_null;
    }

    // pubkey_
    //
    {
      ::bytes_t const& v =
        o.pubkey_;

      bool is_null (false);
      std::size_t cap (i.pubkey_value.capacity ());
      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_image (
        i.pubkey_value,
        i.pubkey_size,
        is_null,
        v);
      i.pubkey_null = is_null;
      grew = grew || (cap != i.pubkey_value.capacity ());
    }

    // is_private_
    //
    {
      bool const& v =
        o.is_private_;

      bool is_null (false);
      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_image (
        i.is_private_value,
        is_null,
        v);
      i.is_private_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::Key, id_sqlite >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id_
    //
    {
      long unsigned int& v =
        o.id_;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // root_keychain_
    //
    {
      ::std::shared_ptr< ::CoinDB::Keychain >& v =
        o.root_keychain_;

      typedef object_traits< ::CoinDB::Keychain > obj_traits;
      typedef odb::pointer_traits< ::std::shared_ptr< ::CoinDB::Keychain > > ptr_traits;

      if (i.root_keychain_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.root_keychain_value,
          i.root_keychain_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // index_
    //
    {
      ::uint32_t& v =
        o.index_;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.index_value,
        i.index_null);
    }

    // pubkey_
    //
    {
      ::bytes_t& v =
        o.pubkey_;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.pubkey_value,
        i.pubkey_size,
        i.pubkey_null);
    }

    // is_private_
    //
    {
      bool& v =
        o.is_private_;

      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_value (
        v,
        i.is_private_value,
        i.is_private_null);
    }
  }

  void access::object_traits_impl< ::CoinDB::Key, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::CoinDB::Key, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Key\" "
  "(\"id\", "
  "\"root_keychain\", "
  "\"index\", "
  "\"pubkey\", "
  "\"is_private\") "
  "VALUES "
  "(?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::CoinDB::Key, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Key\".\"id\", "
  "\"Key\".\"root_keychain\", "
  "\"Key\".\"index\", "
  "\"Key\".\"pubkey\", "
  "\"Key\".\"is_private\" "
  "FROM \"Key\" "
  "WHERE \"Key\".\"id\"=?";

  const char access::object_traits_impl< ::CoinDB::Key, id_sqlite >::update_statement[] =
  "UPDATE \"Key\" "
  "SET "
  "\"root_keychain\"=?, "
  "\"index\"=?, "
  "\"pubkey\"=?, "
  "\"is_private\"=? "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::Key, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Key\" "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::Key, id_sqlite >::query_statement[] =
  "SELECT\n"
  "\"Key\".\"id\",\n"
  "\"Key\".\"root_keychain\",\n"
  "\"Key\".\"index\",\n"
  "\"Key\".\"pubkey\",\n"
  "\"Key\".\"is_private\"\n"
  "FROM \"Key\"\n"
  "LEFT JOIN \"Keychain\" AS \"root_keychain\" ON \"root_keychain\".\"id\"=\"Key\".\"root_keychain\"";

  const char access::object_traits_impl< ::CoinDB::Key, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Key\"";

  const char access::object_traits_impl< ::CoinDB::Key, id_sqlite >::table_name[] =
  "\"Key\"";

  void access::object_traits_impl< ::CoinDB::Key, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id_ = static_cast< id_type > (st.id ());

    id_image_type& i (sts.id_image ());
    init (i, obj.id_);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // derivation_path_
    //
    {
      ::std::vector< unsigned int > const& v =
        obj.derivation_path_;

      derivation_path_traits::persist (
        v,
        esc.derivation_path_);
    }

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::CoinDB::Key, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;
    using sqlite::update_statement;

    callback (db, obj, callback_event::pre_update);

    sqlite::transaction& tr (sqlite::transaction::current ());
    sqlite::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id_);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // derivation_path_
    //
    {
      ::std::vector< unsigned int > const& v =
        obj.derivation_path_;

      derivation_path_traits::update (
        v,
        esc.derivation_path_);
    }

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::CoinDB::Key, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // derivation_path_
    //
    derivation_path_traits::erase (
      esc.derivation_path_);

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::CoinDB::Key, id_sqlite >::pointer_type
  access::object_traits_impl< ::CoinDB::Key, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::CoinDB::Key, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::Key, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id_);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::Key, id_sqlite >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::CoinDB::Key, id_sqlite >::
  load_ (statements_type& sts,
         object_type& obj,
         bool reload)
  {
    ODB_POTENTIALLY_UNUSED (reload);

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // derivation_path_
    //
    {
      ::std::vector< unsigned int >& v =
        obj.derivation_path_;

      derivation_path_traits::load (
        v,
        esc.derivation_path_);
    }
  }

  result< access::object_traits_impl< ::CoinDB::Key, id_sqlite >::object_type >
  access::object_traits_impl< ::CoinDB::Key, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += "\n";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        true,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::CoinDB::Key, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // IndexedLabel
  //

  bool access::composite_value_traits< ::CoinDB::IndexedLabel, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // first
    //
    t[0UL] = false;

    // second
    //
    if (t[1UL])
    {
      i.second_value.capacity (i.second_size);
      grew = true;
    }

    return grew;
  }

  void access::composite_value_traits< ::CoinDB::IndexedLabel, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (b);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);
    ODB_POTENTIALLY_UNUSED (n);

    // first
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.first_value;
    b[n].is_null = &i.first_null;
    n++;

    // second
    //
    b[n].type = sqlite::image_traits<
      ::std::basic_string< char >,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.second_value.data ();
    b[n].size = &i.second_size;
    b[n].capacity = i.second_value.capacity ();
    b[n].is_null = &i.second_null;
    n++;
  }

  bool access::composite_value_traits< ::CoinDB::IndexedLabel, id_sqlite >::
  init (image_type& i,
        const value_type& o,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // first
    //
    {
      unsigned int const& v =
        o.first;

      bool is_null (false);
      sqlite::value_traits<
          unsigned int,
          sqlite::id_integer >::set_image (
        i.first_value,
        is_null,
        v);
      i.first_null = is_null;
    }

    // second
    //
    {
      ::std::basic_string< char > const& v =
        o.second;

      bool is_null (false);
      std::size_t cap (i.second_value.capacity ());
      sqlite::value_traits<
          ::std::basic_string< char >,
          sqlite::id_text >::set_image (
        i.second_value,
        i.second_size,
        is_null,
        v);
      i.second_null = is_null;
      grew = grew || (cap != i.second_value.capacity ());
    }

    return grew;
  }

  void access::composite_value_traits< ::CoinDB::IndexedLabel, id_sqlite >::
  init (value_type& o,
        const image_type&  i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // first
    //
    {
      unsigned int& v =
        o.first;

      sqlite::value_traits<
          unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.first_value,
        i.first_null);
    }

    // second
    //
    {
      ::std::basic_string< char >& v =
        o.second;

      sqlite::value_traits<
          ::std::basic_string< char >,
          sqlite::id_text >::set_value (
        v,
        i.second_value,
        i.second_size,
        i.second_null);
    }
  }

  // AccountBin
  //

  const char alias_traits<  ::CoinDB::Account,
    id_sqlite,
    access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::account_tag>::
  table_name[] = "\"account\"";

  struct access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::extra_statement_cache_type
  {
    sqlite::container_statements_impl< script_label_map_traits > script_label_map_;
    sqlite::container_statements_impl< keychains_traits > keychains_;

    extra_statement_cache_type (
      sqlite::connection& c,
      image_type&,
      sqlite::binding& id,
      sqlite::binding&)
    : script_label_map_ (c, id),
      keychains_ (c, id)
    {
    }
  };

  // script_label_map_
  //

  const char access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::script_label_map_traits::
  select_statement[] =
  "SELECT "
  "\"AccountBin_script_label_map\".\"key\", "
  "\"AccountBin_script_label_map\".\"value\" "
  "FROM \"AccountBin_script_label_map\" "
  "WHERE \"AccountBin_script_label_map\".\"object_id\"=?";

  const char access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::script_label_map_traits::
  insert_statement[] =
  "INSERT INTO \"AccountBin_script_label_map\" "
  "(\"object_id\", "
  "\"key\", "
  "\"value\") "
  "VALUES "
  "(?, ?, ?)";

  const char access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::script_label_map_traits::
  delete_statement[] =
  "DELETE FROM \"AccountBin_script_label_map\" "
  "WHERE \"object_id\"=?";

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::script_label_map_traits::
  bind (sqlite::bind* b,
        const sqlite::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace sqlite;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // key
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &d.key_value;
    b[n].is_null = &d.key_null;
    n++;

    // value
    //
    b[n].type = sqlite::image_traits<
      value_type,
      sqlite::id_text>::bind_value;
    b[n].buffer = d.value_value.data ();
    b[n].size = &d.value_size;
    b[n].capacity = d.value_value.capacity ();
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::script_label_map_traits::
  grow (data_image_type& i,
        bool* t)
  {
    bool grew (false);

    // key
    //
    t[0UL] = false;

    // value
    //
    if (t[1UL])
    {
      i.value_value.capacity (i.value_size);
      grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::script_label_map_traits::
  init (data_image_type& i,
        const key_type* k,
        const value_type& v)
  {
    using namespace sqlite;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // key
    //
    if (k != 0)
    {
      bool is_null (false);
      sqlite::value_traits<
          key_type,
          sqlite::id_integer >::set_image (
        i.key_value,
        is_null,
        *k);
      i.key_null = is_null;
    }

    // value
    //
    {
      bool is_null (false);
      std::size_t cap (i.value_value.capacity ());
      sqlite::value_traits<
          value_type,
          sqlite::id_text >::set_image (
        i.value_value,
        i.value_size,
        is_null,
        v);
      i.value_null = is_null;
      grew = grew || (cap != i.value_value.capacity ());
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::script_label_map_traits::
  init (key_type& k,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // key
    //
    {
      sqlite::value_traits<
          key_type,
          sqlite::id_integer >::set_value (
        k,
        i.key_value,
        i.key_null);
    }

    // value
    //
    {
      sqlite::value_traits<
          value_type,
          sqlite::id_text >::set_value (
        v,
        i.value_value,
        i.value_size,
        i.value_null);
    }
  }

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::script_label_map_traits::
  insert (const key_type& k, const value_type& v, void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &k, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::script_label_map_traits::
  select (key_type& k, value_type& v, void* d)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (k, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::script_label_map_traits::
  delete_ (void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::script_label_map_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::script_label_map_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::script_label_map_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::script_label_map_traits::
  erase (statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    container_traits_type::erase (fs);
  }

  // keychains_
  //

  const char access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::keychains_traits::
  select_statement[] =
  "SELECT "
  "\"AccountBin_keychains\".\"value\" "
  "FROM \"AccountBin_keychains\" "
  "WHERE \"AccountBin_keychains\".\"object_id\"=?";

  const char access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::keychains_traits::
  insert_statement[] =
  "INSERT INTO \"AccountBin_keychains\" "
  "(\"object_id\", "
  "\"value\") "
  "VALUES "
  "(?, ?)";

  const char access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::keychains_traits::
  delete_statement[] =
  "DELETE FROM \"AccountBin_keychains\" "
  "WHERE \"object_id\"=?";

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::keychains_traits::
  bind (sqlite::bind* b,
        const sqlite::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace sqlite;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // value
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &d.value_value;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::keychains_traits::
  grow (data_image_type& i,
        bool* t)
  {
    bool grew (false);

    // value
    //
    t[0UL] = false;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::keychains_traits::
  init (data_image_type& i,
        const value_type& v)
  {
    using namespace sqlite;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // value
    //
    {
      typedef object_traits< ::CoinDB::Keychain > obj_traits;
      typedef odb::pointer_traits< value_type > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.value_value,
          is_null,
          id);
        i.value_null = is_null;
      }
      else
        throw null_pointer ();
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::keychains_traits::
  init (value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // value
    //
    {
      typedef object_traits< ::CoinDB::Keychain > obj_traits;
      typedef odb::pointer_traits< value_type > ptr_traits;

      if (i.value_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.value_value,
          i.value_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }
  }

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::keychains_traits::
  insert (const value_type& v, void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::keychains_traits::
  select (value_type& v, void* d)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (v, di, &sts.connection ().database ());

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());
    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::keychains_traits::
  delete_ (void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::keychains_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::keychains_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());
    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::keychains_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::keychains_traits::
  erase (statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    container_traits_type::erase (fs);
  }

  access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::id_type
  access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id_
    //
    t[0UL] = false;

    // account_
    //
    t[1UL] = false;

    // index_
    //
    t[2UL] = false;

    // name_
    //
    if (t[3UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // script_count_
    //
    t[4UL] = false;

    // next_script_index_
    //
    t[5UL] = false;

    // minsigs_
    //
    t[6UL] = false;

    // hash_
    //
    if (t[7UL])
    {
      i.hash_value.capacity (i.hash_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // id_
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // account_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.account_value;
    b[n].is_null = &i.account_null;
    n++;

    // index_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.index_value;
    b[n].is_null = &i.index_null;
    n++;

    // name_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.name_value.data ();
    b[n].size = &i.name_size;
    b[n].capacity = i.name_value.capacity ();
    b[n].is_null = &i.name_null;
    n++;

    // script_count_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.script_count_value;
    b[n].is_null = &i.script_count_null;
    n++;

    // next_script_index_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.next_script_index_value;
    b[n].is_null = &i.next_script_index_null;
    n++;

    // minsigs_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.minsigs_value;
    b[n].is_null = &i.minsigs_null;
    n++;

    // hash_
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.hash_value.data ();
    b[n].size = &i.hash_size;
    b[n].capacity = i.hash_value.capacity ();
    b[n].is_null = &i.hash_null;
    n++;
  }

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::
  init (image_type& i,
        const object_type& o,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // id_
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.id_;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        v);
      i.id_null = is_null;
    }

    // account_
    //
    {
      ::std::weak_ptr< ::CoinDB::Account > const& v =
        o.account_;

      typedef object_traits< ::CoinDB::Account > obj_traits;
      typedef odb::pointer_traits< ::std::weak_ptr< ::CoinDB::Account > > wptr_traits;
      typedef odb::pointer_traits< wptr_traits::strong_pointer_type > ptr_traits;

      wptr_traits::strong_pointer_type sp (wptr_traits::lock (v));
      bool is_null (ptr_traits::null_ptr (sp));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (sp)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.account_value,
          is_null,
          id);
        i.account_null = is_null;
      }
      else
        i.account_null = true;
    }

    // index_
    //
    {
      ::uint32_t const& v =
        o.index_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_image (
        i.index_value,
        is_null,
        v);
      i.index_null = is_null;
    }

    // name_
    //
    {
      ::std::string const& v =
        o.name_;

      bool is_null (false);
      std::size_t cap (i.name_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.name_value,
        i.name_size,
        is_null,
        v);
      i.name_null = is_null;
      grew = grew || (cap != i.name_value.capacity ());
    }

    // script_count_
    //
    {
      ::uint32_t const& v =
        o.script_count_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_image (
        i.script_count_value,
        is_null,
        v);
      i.script_count_null = is_null;
    }

    // next_script_index_
    //
    {
      ::uint32_t const& v =
        o.next_script_index_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_image (
        i.next_script_index_value,
        is_null,
        v);
      i.next_script_index_null = is_null;
    }

    // minsigs_
    //
    {
      ::uint32_t const& v =
        o.minsigs_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_image (
        i.minsigs_value,
        is_null,
        v);
      i.minsigs_null = is_null;
    }

    // hash_
    //
    {
      ::bytes_t const& v =
        o.hash_;

      bool is_null (false);
      std::size_t cap (i.hash_value.capacity ());
      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_image (
        i.hash_value,
        i.hash_size,
        is_null,
        v);
      i.hash_null = is_null;
      grew = grew || (cap != i.hash_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id_
    //
    {
      long unsigned int& v =
        o.id_;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // account_
    //
    {
      ::std::weak_ptr< ::CoinDB::Account >& v =
        o.account_;

      typedef object_traits< ::CoinDB::Account > obj_traits;
      typedef odb::pointer_traits< ::std::weak_ptr< ::CoinDB::Account > > ptr_traits;

      if (i.account_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.account_value,
          i.account_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));

        if (odb::pointer_traits<ptr_traits::strong_pointer_type>::null_ptr (
              ptr_traits::lock (v)))
          throw session_required ();
      }
    }

    // index_
    //
    {
      ::uint32_t& v =
        o.index_;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.index_value,
        i.index_null);
    }

    // name_
    //
    {
      ::std::string& v =
        o.name_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // script_count_
    //
    {
      ::uint32_t& v =
        o.script_count_;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.script_count_value,
        i.script_count_null);
    }

    // next_script_index_
    //
    {
      ::uint32_t& v =
        o.next_script_index_;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.next_script_index_value,
        i.next_script_index_null);
    }

    // minsigs_
    //
    {
      ::uint32_t& v =
        o.minsigs_;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.minsigs_value,
        i.minsigs_null);
    }

    // hash_
    //
    {
      ::bytes_t& v =
        o.hash_;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.hash_value,
        i.hash_size,
        i.hash_null);
    }
  }

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::persist_statement[] =
  "INSERT INTO \"AccountBin\" "
  "(\"id\", "
  "\"account\", "
  "\"index\", "
  "\"name\", "
  "\"script_count\", "
  "\"next_script_index\", "
  "\"minsigs\", "
  "\"hash\") "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::find_statement[] =
  "SELECT "
  "\"AccountBin\".\"id\", "
  "\"AccountBin\".\"account\", "
  "\"AccountBin\".\"index\", "
  "\"AccountBin\".\"name\", "
  "\"AccountBin\".\"script_count\", "
  "\"AccountBin\".\"next_script_index\", "
  "\"AccountBin\".\"minsigs\", "
  "\"AccountBin\".\"hash\" "
  "FROM \"AccountBin\" "
  "WHERE \"AccountBin\".\"id\"=?";

  const char access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::update_statement[] =
  "UPDATE \"AccountBin\" "
  "SET "
  "\"account\"=?, "
  "\"index\"=?, "
  "\"name\"=?, "
  "\"script_count\"=?, "
  "\"next_script_index\"=?, "
  "\"minsigs\"=?, "
  "\"hash\"=? "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::erase_statement[] =
  "DELETE FROM \"AccountBin\" "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::query_statement[] =
  "SELECT\n"
  "\"AccountBin\".\"id\",\n"
  "\"AccountBin\".\"account\",\n"
  "\"AccountBin\".\"index\",\n"
  "\"AccountBin\".\"name\",\n"
  "\"AccountBin\".\"script_count\",\n"
  "\"AccountBin\".\"next_script_index\",\n"
  "\"AccountBin\".\"minsigs\",\n"
  "\"AccountBin\".\"hash\"\n"
  "FROM \"AccountBin\"\n"
  "LEFT JOIN \"Account\" AS \"account\" ON \"account\".\"id\"=\"AccountBin\".\"account\"";

  const char access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"AccountBin\"";

  const char access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::table_name[] =
  "\"AccountBin\"";

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id_ = static_cast< id_type > (st.id ());

    id_image_type& i (sts.id_image ());
    init (i, obj.id_);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // script_label_map_
    //
    {
      ::CoinDB::IndexedLabelMap const& v =
        obj.script_label_map_;

      script_label_map_traits::persist (
        v,
        esc.script_label_map_);
    }

    // keychains_
    //
    {
      ::CoinDB::KeychainSet const& v =
        obj.keychains_;

      keychains_traits::persist (
        v,
        esc.keychains_);
    }

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;
    using sqlite::update_statement;

    callback (db, obj, callback_event::pre_update);

    sqlite::transaction& tr (sqlite::transaction::current ());
    sqlite::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id_);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // script_label_map_
    //
    {
      ::CoinDB::IndexedLabelMap const& v =
        obj.script_label_map_;

      script_label_map_traits::update (
        v,
        esc.script_label_map_);
    }

    // keychains_
    //
    {
      ::CoinDB::KeychainSet const& v =
        obj.keychains_;

      keychains_traits::update (
        v,
        esc.keychains_);
    }

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // script_label_map_
    //
    script_label_map_traits::erase (
      esc.script_label_map_);

    // keychains_
    //
    keychains_traits::erase (
      esc.keychains_);

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::pointer_type
  access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id_);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::
  load_ (statements_type& sts,
         object_type& obj,
         bool reload)
  {
    ODB_POTENTIALLY_UNUSED (reload);

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // script_label_map_
    //
    {
      ::CoinDB::IndexedLabelMap& v =
        obj.script_label_map_;

      script_label_map_traits::load (
        v,
        esc.script_label_map_);
    }

    // keychains_
    //
    {
      ::CoinDB::KeychainSet& v =
        obj.keychains_;

      keychains_traits::load (
        v,
        esc.keychains_);
    }
  }

  result< access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::object_type >
  access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += "\n";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        true,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::CoinDB::AccountBin, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // Account
  //

  struct access::object_traits_impl< ::CoinDB::Account, id_sqlite >::extra_statement_cache_type
  {
    sqlite::container_statements_impl< keychains_traits > keychains_;
    sqlite::container_statements_impl< bins_traits > bins_;

    extra_statement_cache_type (
      sqlite::connection& c,
      image_type&,
      sqlite::binding& id,
      sqlite::binding&)
    : keychains_ (c, id),
      bins_ (c, id)
    {
    }
  };

  // keychains_
  //

  const char access::object_traits_impl< ::CoinDB::Account, id_sqlite >::keychains_traits::
  select_statement[] =
  "SELECT "
  "\"Account_keychains\".\"value\" "
  "FROM \"Account_keychains\" "
  "WHERE \"Account_keychains\".\"object_id\"=?";

  const char access::object_traits_impl< ::CoinDB::Account, id_sqlite >::keychains_traits::
  insert_statement[] =
  "INSERT INTO \"Account_keychains\" "
  "(\"object_id\", "
  "\"value\") "
  "VALUES "
  "(?, ?)";

  const char access::object_traits_impl< ::CoinDB::Account, id_sqlite >::keychains_traits::
  delete_statement[] =
  "DELETE FROM \"Account_keychains\" "
  "WHERE \"object_id\"=?";

  void access::object_traits_impl< ::CoinDB::Account, id_sqlite >::keychains_traits::
  bind (sqlite::bind* b,
        const sqlite::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace sqlite;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // value
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &d.value_value;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::CoinDB::Account, id_sqlite >::keychains_traits::
  grow (data_image_type& i,
        bool* t)
  {
    bool grew (false);

    // value
    //
    t[0UL] = false;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::CoinDB::Account, id_sqlite >::keychains_traits::
  init (data_image_type& i,
        const value_type& v)
  {
    using namespace sqlite;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // value
    //
    {
      typedef object_traits< ::CoinDB::Keychain > obj_traits;
      typedef odb::pointer_traits< value_type > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.value_value,
          is_null,
          id);
        i.value_null = is_null;
      }
      else
        throw null_pointer ();
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::CoinDB::Account, id_sqlite >::keychains_traits::
  init (value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // value
    //
    {
      typedef object_traits< ::CoinDB::Keychain > obj_traits;
      typedef odb::pointer_traits< value_type > ptr_traits;

      if (i.value_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.value_value,
          i.value_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }
  }

  void access::object_traits_impl< ::CoinDB::Account, id_sqlite >::keychains_traits::
  insert (const value_type& v, void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::CoinDB::Account, id_sqlite >::keychains_traits::
  select (value_type& v, void* d)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (v, di, &sts.connection ().database ());

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());
    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::CoinDB::Account, id_sqlite >::keychains_traits::
  delete_ (void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::CoinDB::Account, id_sqlite >::keychains_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::CoinDB::Account, id_sqlite >::keychains_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());
    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::CoinDB::Account, id_sqlite >::keychains_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::CoinDB::Account, id_sqlite >::keychains_traits::
  erase (statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    container_traits_type::erase (fs);
  }

  // bins_
  //

  const char access::object_traits_impl< ::CoinDB::Account, id_sqlite >::bins_traits::
  select_statement[] =
  "SELECT "
  "\"AccountBin\".\"id\" "
  "FROM \"AccountBin\" "
  "WHERE \"AccountBin\".\"account\"=?";

  const char access::object_traits_impl< ::CoinDB::Account, id_sqlite >::bins_traits::
  insert_statement[] =
  "";

  const char access::object_traits_impl< ::CoinDB::Account, id_sqlite >::bins_traits::
  delete_statement[] =
  "";

  void access::object_traits_impl< ::CoinDB::Account, id_sqlite >::bins_traits::
  bind (sqlite::bind* b,
        const sqlite::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace sqlite;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // value
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &d.value_value;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::CoinDB::Account, id_sqlite >::bins_traits::
  grow (data_image_type& i,
        bool* t)
  {
    bool grew (false);

    // value
    //
    t[0UL] = false;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::CoinDB::Account, id_sqlite >::bins_traits::
  init (value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // value
    //
    {
      typedef object_traits< ::CoinDB::AccountBin > obj_traits;
      typedef odb::pointer_traits< value_type > ptr_traits;

      if (i.value_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.value_value,
          i.value_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }
  }

  void access::object_traits_impl< ::CoinDB::Account, id_sqlite >::bins_traits::
  insert (index_type, const value_type&, void*)
  {
  }

  bool access::object_traits_impl< ::CoinDB::Account, id_sqlite >::bins_traits::
  select (index_type&, value_type& v, void* d)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (v, di, &sts.connection ().database ());

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());
    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::CoinDB::Account, id_sqlite >::bins_traits::
  delete_ (void*)
  {
  }

  void access::object_traits_impl< ::CoinDB::Account, id_sqlite >::bins_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());
    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = false;
    container_traits_type::load (c, more, fs);
  }

  access::object_traits_impl< ::CoinDB::Account, id_sqlite >::id_type
  access::object_traits_impl< ::CoinDB::Account, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::CoinDB::Account, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id_
    //
    t[0UL] = false;

    // name_
    //
    if (t[1UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // minsigs_
    //
    t[2UL] = false;

    // unused_pool_size_
    //
    t[3UL] = false;

    // time_created_
    //
    t[4UL] = false;

    // hash_
    //
    if (t[5UL])
    {
      i.hash_value.capacity (i.hash_size);
      grew = true;
    }

    // compressed_keys_
    //
    t[6UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::Account, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // id_
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // name_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.name_value.data ();
    b[n].size = &i.name_size;
    b[n].capacity = i.name_value.capacity ();
    b[n].is_null = &i.name_null;
    n++;

    // minsigs_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.minsigs_value;
    b[n].is_null = &i.minsigs_null;
    n++;

    // unused_pool_size_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.unused_pool_size_value;
    b[n].is_null = &i.unused_pool_size_null;
    n++;

    // time_created_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.time_created_value;
    b[n].is_null = &i.time_created_null;
    n++;

    // hash_
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.hash_value.data ();
    b[n].size = &i.hash_size;
    b[n].capacity = i.hash_value.capacity ();
    b[n].is_null = &i.hash_null;
    n++;

    // compressed_keys_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.compressed_keys_value;
    b[n].is_null = &i.compressed_keys_null;
    n++;
  }

  void access::object_traits_impl< ::CoinDB::Account, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::CoinDB::Account, id_sqlite >::
  init (image_type& i,
        const object_type& o,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // id_
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.id_;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        v);
      i.id_null = is_null;
    }

    // name_
    //
    {
      ::std::string const& v =
        o.name_;

      bool is_null (false);
      std::size_t cap (i.name_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.name_value,
        i.name_size,
        is_null,
        v);
      i.name_null = is_null;
      grew = grew || (cap != i.name_value.capacity ());
    }

    // minsigs_
    //
    {
      unsigned int const& v =
        o.minsigs_;

      bool is_null (false);
      sqlite::value_traits<
          unsigned int,
          sqlite::id_integer >::set_image (
        i.minsigs_value,
        is_null,
        v);
      i.minsigs_null = is_null;
    }

    // unused_pool_size_
    //
    {
      ::uint32_t const& v =
        o.unused_pool_size_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_image (
        i.unused_pool_size_value,
        is_null,
        v);
      i.unused_pool_size_null = is_null;
    }

    // time_created_
    //
    {
      ::uint32_t const& v =
        o.time_created_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_image (
        i.time_created_value,
        is_null,
        v);
      i.time_created_null = is_null;
    }

    // hash_
    //
    {
      ::bytes_t const& v =
        o.hash_;

      bool is_null (false);
      std::size_t cap (i.hash_value.capacity ());
      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_image (
        i.hash_value,
        i.hash_size,
        is_null,
        v);
      i.hash_null = is_null;
      grew = grew || (cap != i.hash_value.capacity ());
    }

    // compressed_keys_
    //
    {
      bool const& v =
        o.compressed_keys_;

      bool is_null (false);
      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_image (
        i.compressed_keys_value,
        is_null,
        v);
      i.compressed_keys_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::Account, id_sqlite >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id_
    //
    {
      long unsigned int& v =
        o.id_;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // name_
    //
    {
      ::std::string& v =
        o.name_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // minsigs_
    //
    {
      unsigned int& v =
        o.minsigs_;

      sqlite::value_traits<
          unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.minsigs_value,
        i.minsigs_null);
    }

    // unused_pool_size_
    //
    {
      ::uint32_t& v =
        o.unused_pool_size_;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.unused_pool_size_value,
        i.unused_pool_size_null);
    }

    // time_created_
    //
    {
      ::uint32_t& v =
        o.time_created_;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.time_created_value,
        i.time_created_null);
    }

    // hash_
    //
    {
      ::bytes_t& v =
        o.hash_;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.hash_value,
        i.hash_size,
        i.hash_null);
    }

    // compressed_keys_
    //
    {
      bool& v =
        o.compressed_keys_;

      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_value (
        v,
        i.compressed_keys_value,
        i.compressed_keys_null);
    }
  }

  void access::object_traits_impl< ::CoinDB::Account, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::CoinDB::Account, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Account\" "
  "(\"id\", "
  "\"name\", "
  "\"minsigs\", "
  "\"unused_pool_size\", "
  "\"time_created\", "
  "\"hash\", "
  "\"compressed_keys\") "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::CoinDB::Account, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Account\".\"id\", "
  "\"Account\".\"name\", "
  "\"Account\".\"minsigs\", "
  "\"Account\".\"unused_pool_size\", "
  "\"Account\".\"time_created\", "
  "\"Account\".\"hash\", "
  "\"Account\".\"compressed_keys\" "
  "FROM \"Account\" "
  "WHERE \"Account\".\"id\"=?";

  const char access::object_traits_impl< ::CoinDB::Account, id_sqlite >::update_statement[] =
  "UPDATE \"Account\" "
  "SET "
  "\"name\"=?, "
  "\"minsigs\"=?, "
  "\"unused_pool_size\"=?, "
  "\"time_created\"=?, "
  "\"hash\"=?, "
  "\"compressed_keys\"=? "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::Account, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Account\" "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::Account, id_sqlite >::query_statement[] =
  "SELECT "
  "\"Account\".\"id\", "
  "\"Account\".\"name\", "
  "\"Account\".\"minsigs\", "
  "\"Account\".\"unused_pool_size\", "
  "\"Account\".\"time_created\", "
  "\"Account\".\"hash\", "
  "\"Account\".\"compressed_keys\" "
  "FROM \"Account\"";

  const char access::object_traits_impl< ::CoinDB::Account, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Account\"";

  const char access::object_traits_impl< ::CoinDB::Account, id_sqlite >::table_name[] =
  "\"Account\"";

  void access::object_traits_impl< ::CoinDB::Account, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id_ = static_cast< id_type > (st.id ());

    id_image_type& i (sts.id_image ());
    init (i, obj.id_);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // keychains_
    //
    {
      ::CoinDB::KeychainSet const& v =
        obj.keychains_;

      keychains_traits::persist (
        v,
        esc.keychains_);
    }

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::CoinDB::Account, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;
    using sqlite::update_statement;

    callback (db, obj, callback_event::pre_update);

    sqlite::transaction& tr (sqlite::transaction::current ());
    sqlite::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id_);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // keychains_
    //
    {
      ::CoinDB::KeychainSet const& v =
        obj.keychains_;

      keychains_traits::update (
        v,
        esc.keychains_);
    }

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::CoinDB::Account, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // keychains_
    //
    keychains_traits::erase (
      esc.keychains_);

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::CoinDB::Account, id_sqlite >::pointer_type
  access::object_traits_impl< ::CoinDB::Account, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::CoinDB::Account, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::Account, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id_);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::Account, id_sqlite >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::CoinDB::Account, id_sqlite >::
  load_ (statements_type& sts,
         object_type& obj,
         bool reload)
  {
    ODB_POTENTIALLY_UNUSED (reload);

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // keychains_
    //
    {
      ::CoinDB::KeychainSet& v =
        obj.keychains_;

      keychains_traits::load (
        v,
        esc.keychains_);
    }

    // bins_
    //
    {
      ::CoinDB::AccountBinVector& v =
        obj.bins_;

      bins_traits::load (
        v,
        esc.bins_);
    }
  }

  result< access::object_traits_impl< ::CoinDB::Account, id_sqlite >::object_type >
  access::object_traits_impl< ::CoinDB::Account, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::CoinDB::Account, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // SigningScript
  //

  const char alias_traits<  ::CoinDB::Account,
    id_sqlite,
    access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::account_tag>::
  table_name[] = "\"account\"";

  const char alias_traits<  ::CoinDB::AccountBin,
    id_sqlite,
    access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::account_bin_tag>::
  table_name[] = "\"account_bin\"";

  const char alias_traits<  ::CoinDB::Contact,
    id_sqlite,
    access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::contact_tag>::
  table_name[] = "\"contact\"";

  struct access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::extra_statement_cache_type
  {
    sqlite::container_statements_impl< keys_traits > keys_;

    extra_statement_cache_type (
      sqlite::connection& c,
      image_type&,
      sqlite::binding& id,
      sqlite::binding&)
    : keys_ (c, id)
    {
    }
  };

  // keys_
  //

  const char access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::keys_traits::
  select_statement[] =
  "SELECT "
  "\"SigningScript_keys\".\"index\", "
  "\"SigningScript_keys\".\"value\" "
  "FROM \"SigningScript_keys\" "
  "WHERE \"SigningScript_keys\".\"object_id\"=? ORDER BY \"SigningScript_keys\".\"index\"";

  const char access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::keys_traits::
  insert_statement[] =
  "INSERT INTO \"SigningScript_keys\" "
  "(\"object_id\", "
  "\"index\", "
  "\"value\") "
  "VALUES "
  "(?, ?, ?)";

  const char access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::keys_traits::
  delete_statement[] =
  "DELETE FROM \"SigningScript_keys\" "
  "WHERE \"object_id\"=?";

  void access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::keys_traits::
  bind (sqlite::bind* b,
        const sqlite::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace sqlite;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // index
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &d.index_value;
    b[n].is_null = &d.index_null;
    n++;

    // value
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &d.value_value;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::keys_traits::
  grow (data_image_type& i,
        bool* t)
  {
    bool grew (false);

    // index
    //
    t[0UL] = false;

    // value
    //
    t[1UL] = false;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::keys_traits::
  init (data_image_type& i,
        index_type* j,
        const value_type& v)
  {
    using namespace sqlite;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // index
    //
    if (j != 0)
    {
      bool is_null (false);
      sqlite::value_traits<
          index_type,
          sqlite::id_integer >::set_image (
        i.index_value,
        is_null,
        *j);
      i.index_null = is_null;
    }

    // value
    //
    {
      typedef object_traits< ::CoinDB::Key > obj_traits;
      typedef odb::pointer_traits< value_type > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.value_value,
          is_null,
          id);
        i.value_null = is_null;
      }
      else
        i.value_null = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::keys_traits::
  init (index_type& j,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // index
    //
    {
      sqlite::value_traits<
          index_type,
          sqlite::id_integer >::set_value (
        j,
        i.index_value,
        i.index_null);
    }

    // value
    //
    {
      typedef object_traits< ::CoinDB::Key > obj_traits;
      typedef odb::pointer_traits< value_type > ptr_traits;

      if (i.value_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.value_value,
          i.value_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }
  }

  void access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::keys_traits::
  insert (index_type i, const value_type& v, void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &i, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::keys_traits::
  select (index_type& i, value_type& v, void* d)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (i, v, di, &sts.connection ().database ());

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());
    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::keys_traits::
  delete_ (void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::keys_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::keys_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());
    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::keys_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::keys_traits::
  erase (statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::erase (fs);
  }

  access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::id_type
  access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id_
    //
    t[0UL] = false;

    // account_
    //
    t[1UL] = false;

    // account_bin_
    //
    t[2UL] = false;

    // index_
    //
    t[3UL] = false;

    // label_
    //
    if (t[4UL])
    {
      i.label_value.capacity (i.label_size);
      grew = true;
    }

    // status_
    //
    t[5UL] = false;

    // txinscript_
    //
    if (t[6UL])
    {
      i.txinscript_value.capacity (i.txinscript_size);
      grew = true;
    }

    // txoutscript_
    //
    if (t[7UL])
    {
      i.txoutscript_value.capacity (i.txoutscript_size);
      grew = true;
    }

    // contact_
    //
    t[8UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // id_
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // account_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.account_value;
    b[n].is_null = &i.account_null;
    n++;

    // account_bin_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.account_bin_value;
    b[n].is_null = &i.account_bin_null;
    n++;

    // index_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.index_value;
    b[n].is_null = &i.index_null;
    n++;

    // label_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.label_value.data ();
    b[n].size = &i.label_size;
    b[n].capacity = i.label_value.capacity ();
    b[n].is_null = &i.label_null;
    n++;

    // status_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.status_value;
    b[n].is_null = &i.status_null;
    n++;

    // txinscript_
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.txinscript_value.data ();
    b[n].size = &i.txinscript_size;
    b[n].capacity = i.txinscript_value.capacity ();
    b[n].is_null = &i.txinscript_null;
    n++;

    // txoutscript_
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.txoutscript_value.data ();
    b[n].size = &i.txoutscript_size;
    b[n].capacity = i.txoutscript_value.capacity ();
    b[n].is_null = &i.txoutscript_null;
    n++;

    // contact_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.contact_value;
    b[n].is_null = &i.contact_null;
    n++;
  }

  void access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::
  init (image_type& i,
        const object_type& o,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // id_
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.id_;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        v);
      i.id_null = is_null;
    }

    // account_
    //
    {
      ::std::shared_ptr< ::CoinDB::Account > const& v =
        o.account_;

      typedef object_traits< ::CoinDB::Account > obj_traits;
      typedef odb::pointer_traits< ::std::shared_ptr< ::CoinDB::Account > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.account_value,
          is_null,
          id);
        i.account_null = is_null;
      }
      else
        i.account_null = true;
    }

    // account_bin_
    //
    {
      ::std::shared_ptr< ::CoinDB::AccountBin > const& v =
        o.account_bin_;

      typedef object_traits< ::CoinDB::AccountBin > obj_traits;
      typedef odb::pointer_traits< ::std::shared_ptr< ::CoinDB::AccountBin > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.account_bin_value,
          is_null,
          id);
        i.account_bin_null = is_null;
      }
      else
        i.account_bin_null = true;
    }

    // index_
    //
    {
      ::uint32_t const& v =
        o.index_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_image (
        i.index_value,
        is_null,
        v);
      i.index_null = is_null;
    }

    // label_
    //
    {
      ::std::string const& v =
        o.label_;

      bool is_null (false);
      std::size_t cap (i.label_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.label_value,
        i.label_size,
        is_null,
        v);
      i.label_null = is_null;
      grew = grew || (cap != i.label_value.capacity ());
    }

    // status_
    //
    {
      ::CoinDB::SigningScript::status_t const& v =
        o.status_;

      bool is_null (false);
      sqlite::value_traits<
          ::CoinDB::SigningScript::status_t,
          sqlite::id_integer >::set_image (
        i.status_value,
        is_null,
        v);
      i.status_null = is_null;
    }

    // txinscript_
    //
    {
      ::bytes_t const& v =
        o.txinscript_;

      bool is_null (false);
      std::size_t cap (i.txinscript_value.capacity ());
      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_image (
        i.txinscript_value,
        i.txinscript_size,
        is_null,
        v);
      i.txinscript_null = is_null;
      grew = grew || (cap != i.txinscript_value.capacity ());
    }

    // txoutscript_
    //
    {
      ::bytes_t const& v =
        o.txoutscript_;

      bool is_null (false);
      std::size_t cap (i.txoutscript_value.capacity ());
      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_image (
        i.txoutscript_value,
        i.txoutscript_size,
        is_null,
        v);
      i.txoutscript_null = is_null;
      grew = grew || (cap != i.txoutscript_value.capacity ());
    }

    // contact_
    //
    {
      ::std::shared_ptr< ::CoinDB::Contact > const& v =
        o.contact_;

      typedef object_traits< ::CoinDB::Contact > obj_traits;
      typedef odb::pointer_traits< ::std::shared_ptr< ::CoinDB::Contact > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.contact_value,
          is_null,
          id);
        i.contact_null = is_null;
      }
      else
        i.contact_null = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id_
    //
    {
      long unsigned int& v =
        o.id_;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // account_
    //
    {
      ::std::shared_ptr< ::CoinDB::Account >& v =
        o.account_;

      typedef object_traits< ::CoinDB::Account > obj_traits;
      typedef odb::pointer_traits< ::std::shared_ptr< ::CoinDB::Account > > ptr_traits;

      if (i.account_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.account_value,
          i.account_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // account_bin_
    //
    {
      ::std::shared_ptr< ::CoinDB::AccountBin >& v =
        o.account_bin_;

      typedef object_traits< ::CoinDB::AccountBin > obj_traits;
      typedef odb::pointer_traits< ::std::shared_ptr< ::CoinDB::AccountBin > > ptr_traits;

      if (i.account_bin_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.account_bin_value,
          i.account_bin_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // index_
    //
    {
      ::uint32_t& v =
        o.index_;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.index_value,
        i.index_null);
    }

    // label_
    //
    {
      ::std::string& v =
        o.label_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.label_value,
        i.label_size,
        i.label_null);
    }

    // status_
    //
    {
      ::CoinDB::SigningScript::status_t& v =
        o.status_;

      sqlite::value_traits<
          ::CoinDB::SigningScript::status_t,
          sqlite::id_integer >::set_value (
        v,
        i.status_value,
        i.status_null);
    }

    // txinscript_
    //
    {
      ::bytes_t& v =
        o.txinscript_;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.txinscript_value,
        i.txinscript_size,
        i.txinscript_null);
    }

    // txoutscript_
    //
    {
      ::bytes_t& v =
        o.txoutscript_;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.txoutscript_value,
        i.txoutscript_size,
        i.txoutscript_null);
    }

    // contact_
    //
    {
      ::std::shared_ptr< ::CoinDB::Contact >& v =
        o.contact_;

      typedef object_traits< ::CoinDB::Contact > obj_traits;
      typedef odb::pointer_traits< ::std::shared_ptr< ::CoinDB::Contact > > ptr_traits;

      if (i.contact_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.contact_value,
          i.contact_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }
  }

  void access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::persist_statement[] =
  "INSERT INTO \"SigningScript\" "
  "(\"id\", "
  "\"account\", "
  "\"account_bin\", "
  "\"index\", "
  "\"label\", "
  "\"status\", "
  "\"txinscript\", "
  "\"txoutscript\", "
  "\"contact\") "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::find_statement[] =
  "SELECT "
  "\"SigningScript\".\"id\", "
  "\"SigningScript\".\"account\", "
  "\"SigningScript\".\"account_bin\", "
  "\"SigningScript\".\"index\", "
  "\"SigningScript\".\"label\", "
  "\"SigningScript\".\"status\", "
  "\"SigningScript\".\"txinscript\", "
  "\"SigningScript\".\"txoutscript\", "
  "\"SigningScript\".\"contact\" "
  "FROM \"SigningScript\" "
  "WHERE \"SigningScript\".\"id\"=?";

  const char access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::update_statement[] =
  "UPDATE \"SigningScript\" "
  "SET "
  "\"account\"=?, "
  "\"account_bin\"=?, "
  "\"index\"=?, "
  "\"label\"=?, "
  "\"status\"=?, "
  "\"txinscript\"=?, "
  "\"txoutscript\"=?, "
  "\"contact\"=? "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::erase_statement[] =
  "DELETE FROM \"SigningScript\" "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::query_statement[] =
  "SELECT\n"
  "\"SigningScript\".\"id\",\n"
  "\"SigningScript\".\"account\",\n"
  "\"SigningScript\".\"account_bin\",\n"
  "\"SigningScript\".\"index\",\n"
  "\"SigningScript\".\"label\",\n"
  "\"SigningScript\".\"status\",\n"
  "\"SigningScript\".\"txinscript\",\n"
  "\"SigningScript\".\"txoutscript\",\n"
  "\"SigningScript\".\"contact\"\n"
  "FROM \"SigningScript\"\n"
  "LEFT JOIN \"Account\" AS \"account\" ON \"account\".\"id\"=\"SigningScript\".\"account\"\n"
  "LEFT JOIN \"AccountBin\" AS \"account_bin\" ON \"account_bin\".\"id\"=\"SigningScript\".\"account_bin\"\n"
  "LEFT JOIN \"Contact\" AS \"contact\" ON \"contact\".\"id\"=\"SigningScript\".\"contact\"";

  const char access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"SigningScript\"";

  const char access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::table_name[] =
  "\"SigningScript\"";

  void access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id_ = static_cast< id_type > (st.id ());

    id_image_type& i (sts.id_image ());
    init (i, obj.id_);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // keys_
    //
    {
      ::CoinDB::KeyVector const& v =
        obj.keys_;

      keys_traits::persist (
        v,
        esc.keys_);
    }

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;
    using sqlite::update_statement;

    callback (db, obj, callback_event::pre_update);

    sqlite::transaction& tr (sqlite::transaction::current ());
    sqlite::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id_);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // keys_
    //
    {
      ::CoinDB::KeyVector const& v =
        obj.keys_;

      keys_traits::update (
        v,
        esc.keys_);
    }

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // keys_
    //
    keys_traits::erase (
      esc.keys_);

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::pointer_type
  access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id_);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::
  load_ (statements_type& sts,
         object_type& obj,
         bool reload)
  {
    ODB_POTENTIALLY_UNUSED (reload);

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // keys_
    //
    {
      ::CoinDB::KeyVector& v =
        obj.keys_;

      keys_traits::load (
        v,
        esc.keys_);
    }
  }

  result< access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::object_type >
  access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += "\n";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        true,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::CoinDB::SigningScript, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // BlockHeader
  //

  struct access::object_traits_impl< ::CoinDB::BlockHeader, id_sqlite >::extra_statement_cache_type
  {
    extra_statement_cache_type (
      sqlite::connection&,
      image_type&,
      sqlite::binding&,
      sqlite::binding&)
    {
    }
  };

  access::object_traits_impl< ::CoinDB::BlockHeader, id_sqlite >::id_type
  access::object_traits_impl< ::CoinDB::BlockHeader, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::CoinDB::BlockHeader, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id_
    //
    t[0UL] = false;

    // hash_
    //
    if (t[1UL])
    {
      i.hash_value.capacity (i.hash_size);
      grew = true;
    }

    // height_
    //
    t[2UL] = false;

    // version_
    //
    t[3UL] = false;

    // prevhash_
    //
    if (t[4UL])
    {
      i.prevhash_value.capacity (i.prevhash_size);
      grew = true;
    }

    // merkleroot_
    //
    if (t[5UL])
    {
      i.merkleroot_value.capacity (i.merkleroot_size);
      grew = true;
    }

    // timestamp_
    //
    t[6UL] = false;

    // bits_
    //
    t[7UL] = false;

    // nonce_
    //
    t[8UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::BlockHeader, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // id_
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // hash_
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.hash_value.data ();
    b[n].size = &i.hash_size;
    b[n].capacity = i.hash_value.capacity ();
    b[n].is_null = &i.hash_null;
    n++;

    // height_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.height_value;
    b[n].is_null = &i.height_null;
    n++;

    // version_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.version_value;
    b[n].is_null = &i.version_null;
    n++;

    // prevhash_
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.prevhash_value.data ();
    b[n].size = &i.prevhash_size;
    b[n].capacity = i.prevhash_value.capacity ();
    b[n].is_null = &i.prevhash_null;
    n++;

    // merkleroot_
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.merkleroot_value.data ();
    b[n].size = &i.merkleroot_size;
    b[n].capacity = i.merkleroot_value.capacity ();
    b[n].is_null = &i.merkleroot_null;
    n++;

    // timestamp_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.timestamp_value;
    b[n].is_null = &i.timestamp_null;
    n++;

    // bits_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.bits_value;
    b[n].is_null = &i.bits_null;
    n++;

    // nonce_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.nonce_value;
    b[n].is_null = &i.nonce_null;
    n++;
  }

  void access::object_traits_impl< ::CoinDB::BlockHeader, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::CoinDB::BlockHeader, id_sqlite >::
  init (image_type& i,
        const object_type& o,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // id_
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.id_;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        v);
      i.id_null = is_null;
    }

    // hash_
    //
    {
      ::bytes_t const& v =
        o.hash_;

      bool is_null (false);
      std::size_t cap (i.hash_value.capacity ());
      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_image (
        i.hash_value,
        i.hash_size,
        is_null,
        v);
      i.hash_null = is_null;
      grew = grew || (cap != i.hash_value.capacity ());
    }

    // height_
    //
    {
      ::uint32_t const& v =
        o.height_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_image (
        i.height_value,
        is_null,
        v);
      i.height_null = is_null;
    }

    // version_
    //
    {
      ::uint32_t const& v =
        o.version_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_image (
        i.version_value,
        is_null,
        v);
      i.version_null = is_null;
    }

    // prevhash_
    //
    {
      ::bytes_t const& v =
        o.prevhash_;

      bool is_null (false);
      std::size_t cap (i.prevhash_value.capacity ());
      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_image (
        i.prevhash_value,
        i.prevhash_size,
        is_null,
        v);
      i.prevhash_null = is_null;
      grew = grew || (cap != i.prevhash_value.capacity ());
    }

    // merkleroot_
    //
    {
      ::bytes_t const& v =
        o.merkleroot_;

      bool is_null (false);
      std::size_t cap (i.merkleroot_value.capacity ());
      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_image (
        i.merkleroot_value,
        i.merkleroot_size,
        is_null,
        v);
      i.merkleroot_null = is_null;
      grew = grew || (cap != i.merkleroot_value.capacity ());
    }

    // timestamp_
    //
    {
      ::uint32_t const& v =
        o.timestamp_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_image (
        i.timestamp_value,
        is_null,
        v);
      i.timestamp_null = is_null;
    }

    // bits_
    //
    {
      ::uint32_t const& v =
        o.bits_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_image (
        i.bits_value,
        is_null,
        v);
      i.bits_null = is_null;
    }

    // nonce_
    //
    {
      ::uint32_t const& v =
        o.nonce_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_image (
        i.nonce_value,
        is_null,
        v);
      i.nonce_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::BlockHeader, id_sqlite >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id_
    //
    {
      long unsigned int& v =
        o.id_;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // hash_
    //
    {
      ::bytes_t& v =
        o.hash_;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.hash_value,
        i.hash_size,
        i.hash_null);
    }

    // height_
    //
    {
      ::uint32_t& v =
        o.height_;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.height_value,
        i.height_null);
    }

    // version_
    //
    {
      ::uint32_t& v =
        o.version_;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.version_value,
        i.version_null);
    }

    // prevhash_
    //
    {
      ::bytes_t& v =
        o.prevhash_;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.prevhash_value,
        i.prevhash_size,
        i.prevhash_null);
    }

    // merkleroot_
    //
    {
      ::bytes_t& v =
        o.merkleroot_;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.merkleroot_value,
        i.merkleroot_size,
        i.merkleroot_null);
    }

    // timestamp_
    //
    {
      ::uint32_t& v =
        o.timestamp_;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.timestamp_value,
        i.timestamp_null);
    }

    // bits_
    //
    {
      ::uint32_t& v =
        o.bits_;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.bits_value,
        i.bits_null);
    }

    // nonce_
    //
    {
      ::uint32_t& v =
        o.nonce_;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.nonce_value,
        i.nonce_null);
    }
  }

  void access::object_traits_impl< ::CoinDB::BlockHeader, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::CoinDB::BlockHeader, id_sqlite >::persist_statement[] =
  "INSERT INTO \"BlockHeader\" "
  "(\"id\", "
  "\"hash\", "
  "\"height\", "
  "\"version\", "
  "\"prevhash\", "
  "\"merkleroot\", "
  "\"timestamp\", "
  "\"bits\", "
  "\"nonce\") "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::CoinDB::BlockHeader, id_sqlite >::find_statement[] =
  "SELECT "
  "\"BlockHeader\".\"id\", "
  "\"BlockHeader\".\"hash\", "
  "\"BlockHeader\".\"height\", "
  "\"BlockHeader\".\"version\", "
  "\"BlockHeader\".\"prevhash\", "
  "\"BlockHeader\".\"merkleroot\", "
  "\"BlockHeader\".\"timestamp\", "
  "\"BlockHeader\".\"bits\", "
  "\"BlockHeader\".\"nonce\" "
  "FROM \"BlockHeader\" "
  "WHERE \"BlockHeader\".\"id\"=?";

  const char access::object_traits_impl< ::CoinDB::BlockHeader, id_sqlite >::update_statement[] =
  "UPDATE \"BlockHeader\" "
  "SET "
  "\"hash\"=?, "
  "\"height\"=?, "
  "\"version\"=?, "
  "\"prevhash\"=?, "
  "\"merkleroot\"=?, "
  "\"timestamp\"=?, "
  "\"bits\"=?, "
  "\"nonce\"=? "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::BlockHeader, id_sqlite >::erase_statement[] =
  "DELETE FROM \"BlockHeader\" "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::BlockHeader, id_sqlite >::query_statement[] =
  "SELECT "
  "\"BlockHeader\".\"id\", "
  "\"BlockHeader\".\"hash\", "
  "\"BlockHeader\".\"height\", "
  "\"BlockHeader\".\"version\", "
  "\"BlockHeader\".\"prevhash\", "
  "\"BlockHeader\".\"merkleroot\", "
  "\"BlockHeader\".\"timestamp\", "
  "\"BlockHeader\".\"bits\", "
  "\"BlockHeader\".\"nonce\" "
  "FROM \"BlockHeader\"";

  const char access::object_traits_impl< ::CoinDB::BlockHeader, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"BlockHeader\"";

  const char access::object_traits_impl< ::CoinDB::BlockHeader, id_sqlite >::table_name[] =
  "\"BlockHeader\"";

  void access::object_traits_impl< ::CoinDB::BlockHeader, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id_ = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::CoinDB::BlockHeader, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;
    using sqlite::update_statement;

    callback (db, obj, callback_event::pre_update);

    sqlite::transaction& tr (sqlite::transaction::current ());
    sqlite::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id_);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::CoinDB::BlockHeader, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::CoinDB::BlockHeader, id_sqlite >::pointer_type
  access::object_traits_impl< ::CoinDB::BlockHeader, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::CoinDB::BlockHeader, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::BlockHeader, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id_);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::BlockHeader, id_sqlite >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::CoinDB::BlockHeader, id_sqlite >::object_type >
  access::object_traits_impl< ::CoinDB::BlockHeader, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += " ";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        false,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::CoinDB::BlockHeader, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // MerkleBlock
  //

  const char alias_traits<  ::CoinDB::BlockHeader,
    id_sqlite,
    access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::blockheader_tag>::
  table_name[] = "\"blockheader\"";

  struct access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::extra_statement_cache_type
  {
    sqlite::container_statements_impl< hashes_traits > hashes_;

    extra_statement_cache_type (
      sqlite::connection& c,
      image_type&,
      sqlite::binding& id,
      sqlite::binding&)
    : hashes_ (c, id)
    {
    }
  };

  // hashes_
  //

  const char access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::hashes_traits::
  select_statement[] =
  "SELECT "
  "\"MerkleBlock_hashes\".\"index\", "
  "\"MerkleBlock_hashes\".\"value\" "
  "FROM \"MerkleBlock_hashes\" "
  "WHERE \"MerkleBlock_hashes\".\"object_id\"=? ORDER BY \"MerkleBlock_hashes\".\"index\"";

  const char access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::hashes_traits::
  insert_statement[] =
  "INSERT INTO \"MerkleBlock_hashes\" "
  "(\"object_id\", "
  "\"index\", "
  "\"value\") "
  "VALUES "
  "(?, ?, ?)";

  const char access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::hashes_traits::
  delete_statement[] =
  "DELETE FROM \"MerkleBlock_hashes\" "
  "WHERE \"object_id\"=?";

  void access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::hashes_traits::
  bind (sqlite::bind* b,
        const sqlite::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace sqlite;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // index
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &d.index_value;
    b[n].is_null = &d.index_null;
    n++;

    // value
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = d.value_value.data ();
    b[n].size = &d.value_size;
    b[n].capacity = d.value_value.capacity ();
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::hashes_traits::
  grow (data_image_type& i,
        bool* t)
  {
    bool grew (false);

    // index
    //
    t[0UL] = false;

    // value
    //
    if (t[1UL])
    {
      i.value_value.capacity (i.value_size);
      grew = true;
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::hashes_traits::
  init (data_image_type& i,
        index_type* j,
        const value_type& v)
  {
    using namespace sqlite;

    statement_kind sk (statement_insert);
    ODB_POTENTIALLY_UNUSED (sk);

    bool grew (false);

    // index
    //
    if (j != 0)
    {
      bool is_null (false);
      sqlite::value_traits<
          index_type,
          sqlite::id_integer >::set_image (
        i.index_value,
        is_null,
        *j);
      i.index_null = is_null;
    }

    // value
    //
    {
      bool is_null (false);
      std::size_t cap (i.value_value.capacity ());
      sqlite::value_traits<
          value_type,
          sqlite::id_blob >::set_image (
        i.value_value,
        i.value_size,
        is_null,
        v);
      i.value_null = is_null;
      grew = grew || (cap != i.value_value.capacity ());
    }

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::hashes_traits::
  init (index_type& j,
        value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // index
    //
    {
      sqlite::value_traits<
          index_type,
          sqlite::id_integer >::set_value (
        j,
        i.index_value,
        i.index_null);
    }

    // value
    //
    {
      sqlite::value_traits<
          value_type,
          sqlite::id_blob >::set_value (
        v,
        i.value_value,
        i.value_size,
        i.value_null);
    }
  }

  void access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::hashes_traits::
  insert (index_type i, const value_type& v, void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (di, &i, v);

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    if (!sts.insert_statement ().execute ())
      throw object_already_persistent ();
  }

  bool access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::hashes_traits::
  select (index_type& i, value_type& v, void* d)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (i, v, di, &sts.connection ().database ());

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, sts.id_binding ().count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::hashes_traits::
  delete_ (void* d)
  {
    using namespace sqlite;

    statements_type& sts (*static_cast< statements_type* > (d));
    sts.delete_statement ().execute ();
  }

  void access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::hashes_traits::
  persist (const container_type& c,
           statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::persist (c, fs);
  }

  void access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::hashes_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      data_image_type& di (sts.data_image ());
      grow (di, sts.select_image_truncated ());

      if (sts.data_binding_test_version ())
      {
        bind (sts.data_bind (), 0, id.count, di);
        sts.data_binding_update_version ();
        st.refetch ();
      }
    }

    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::load (c, more, fs);
  }

  void access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::hashes_traits::
  update (const container_type& c,
          statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::update (c, fs);
  }

  void access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::hashes_traits::
  erase (statements_type& sts)
  {
    using namespace sqlite;

    functions_type& fs (sts.functions ());
    fs.ordered_ = true;
    container_traits_type::erase (fs);
  }

  access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::id_type
  access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id_
    //
    t[0UL] = false;

    // blockheader_
    //
    t[1UL] = false;

    // txcount_
    //
    t[2UL] = false;

    // flags_
    //
    if (t[3UL])
    {
      i.flags_value.capacity (i.flags_size);
      grew = true;
    }

    // txsinserted_
    //
    t[4UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // id_
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // blockheader_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.blockheader_value;
    b[n].is_null = &i.blockheader_null;
    n++;

    // txcount_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.txcount_value;
    b[n].is_null = &i.txcount_null;
    n++;

    // flags_
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.flags_value.data ();
    b[n].size = &i.flags_size;
    b[n].capacity = i.flags_value.capacity ();
    b[n].is_null = &i.flags_null;
    n++;

    // txsinserted_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.txsinserted_value;
    b[n].is_null = &i.txsinserted_null;
    n++;
  }

  void access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::
  init (image_type& i,
        const object_type& o,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // id_
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.id_;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        v);
      i.id_null = is_null;
    }

    // blockheader_
    //
    {
      ::std::shared_ptr< ::CoinDB::BlockHeader > const& v =
        o.blockheader_;

      typedef object_traits< ::CoinDB::BlockHeader > obj_traits;
      typedef odb::pointer_traits< ::std::shared_ptr< ::CoinDB::BlockHeader > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.blockheader_value,
          is_null,
          id);
        i.blockheader_null = is_null;
      }
      else
        throw null_pointer ();
    }

    // txcount_
    //
    {
      ::uint32_t const& v =
        o.txcount_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_image (
        i.txcount_value,
        is_null,
        v);
      i.txcount_null = is_null;
    }

    // flags_
    //
    {
      ::bytes_t const& v =
        o.flags_;

      bool is_null (false);
      std::size_t cap (i.flags_value.capacity ());
      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_image (
        i.flags_value,
        i.flags_size,
        is_null,
        v);
      i.flags_null = is_null;
      grew = grew || (cap != i.flags_value.capacity ());
    }

    // txsinserted_
    //
    {
      bool const& v =
        o.txsinserted_;

      bool is_null (false);
      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_image (
        i.txsinserted_value,
        is_null,
        v);
      i.txsinserted_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id_
    //
    {
      long unsigned int& v =
        o.id_;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // blockheader_
    //
    {
      ::std::shared_ptr< ::CoinDB::BlockHeader >& v =
        o.blockheader_;

      typedef object_traits< ::CoinDB::BlockHeader > obj_traits;
      typedef odb::pointer_traits< ::std::shared_ptr< ::CoinDB::BlockHeader > > ptr_traits;

      if (i.blockheader_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.blockheader_value,
          i.blockheader_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // txcount_
    //
    {
      ::uint32_t& v =
        o.txcount_;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.txcount_value,
        i.txcount_null);
    }

    // flags_
    //
    {
      ::bytes_t& v =
        o.flags_;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.flags_value,
        i.flags_size,
        i.flags_null);
    }

    // txsinserted_
    //
    {
      bool& v =
        o.txsinserted_;

      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_value (
        v,
        i.txsinserted_value,
        i.txsinserted_null);
    }
  }

  void access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::persist_statement[] =
  "INSERT INTO \"MerkleBlock\" "
  "(\"id\", "
  "\"blockheader\", "
  "\"txcount\", "
  "\"flags\", "
  "\"txsinserted\") "
  "VALUES "
  "(?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::find_statement[] =
  "SELECT "
  "\"MerkleBlock\".\"id\", "
  "\"MerkleBlock\".\"blockheader\", "
  "\"MerkleBlock\".\"txcount\", "
  "\"MerkleBlock\".\"flags\", "
  "\"MerkleBlock\".\"txsinserted\" "
  "FROM \"MerkleBlock\" "
  "WHERE \"MerkleBlock\".\"id\"=?";

  const char access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::update_statement[] =
  "UPDATE \"MerkleBlock\" "
  "SET "
  "\"blockheader\"=?, "
  "\"txcount\"=?, "
  "\"flags\"=?, "
  "\"txsinserted\"=? "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::erase_statement[] =
  "DELETE FROM \"MerkleBlock\" "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::query_statement[] =
  "SELECT\n"
  "\"MerkleBlock\".\"id\",\n"
  "\"MerkleBlock\".\"blockheader\",\n"
  "\"MerkleBlock\".\"txcount\",\n"
  "\"MerkleBlock\".\"flags\",\n"
  "\"MerkleBlock\".\"txsinserted\"\n"
  "FROM \"MerkleBlock\"\n"
  "LEFT JOIN \"BlockHeader\" AS \"blockheader\" ON \"blockheader\".\"id\"=\"MerkleBlock\".\"blockheader\"";

  const char access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"MerkleBlock\"";

  const char access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::table_name[] =
  "\"MerkleBlock\"";

  void access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id_ = static_cast< id_type > (st.id ());

    id_image_type& i (sts.id_image ());
    init (i, obj.id_);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // hashes_
    //
    {
      ::std::vector< ::std::vector< unsigned char > > const& v =
        obj.hashes_;

      hashes_traits::persist (
        v,
        esc.hashes_);
    }

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;
    using sqlite::update_statement;

    callback (db, obj, callback_event::pre_update);

    sqlite::transaction& tr (sqlite::transaction::current ());
    sqlite::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id_);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // hashes_
    //
    {
      ::std::vector< ::std::vector< unsigned char > > const& v =
        obj.hashes_;

      hashes_traits::update (
        v,
        esc.hashes_);
    }

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // hashes_
    //
    hashes_traits::erase (
      esc.hashes_);

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::pointer_type
  access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id_);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::
  load_ (statements_type& sts,
         object_type& obj,
         bool reload)
  {
    ODB_POTENTIALLY_UNUSED (reload);

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // hashes_
    //
    {
      ::std::vector< ::std::vector< unsigned char > >& v =
        obj.hashes_;

      hashes_traits::load (
        v,
        esc.hashes_);
    }
  }

  result< access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::object_type >
  access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += "\n";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        true,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::CoinDB::MerkleBlock, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // TxIn
  //

  const char alias_traits<  ::CoinDB::Tx,
    id_sqlite,
    access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::tx_tag>::
  table_name[] = "\"tx\"";

  const char alias_traits<  ::CoinDB::TxOut,
    id_sqlite,
    access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::outpoint_tag>::
  table_name[] = "\"outpoint\"";

  struct access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::extra_statement_cache_type
  {
    extra_statement_cache_type (
      sqlite::connection&,
      image_type&,
      sqlite::binding&,
      sqlite::binding&)
    {
    }
  };

  access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::id_type
  access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id_
    //
    t[0UL] = false;

    // outhash_
    //
    if (t[1UL])
    {
      i.outhash_value.capacity (i.outhash_size);
      grew = true;
    }

    // outindex_
    //
    t[2UL] = false;

    // script_
    //
    if (t[3UL])
    {
      i.script_value.capacity (i.script_size);
      grew = true;
    }

    // sequence_
    //
    t[4UL] = false;

    // tx_
    //
    t[5UL] = false;

    // txindex_
    //
    t[6UL] = false;

    // outpoint_
    //
    t[7UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // id_
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // outhash_
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.outhash_value.data ();
    b[n].size = &i.outhash_size;
    b[n].capacity = i.outhash_value.capacity ();
    b[n].is_null = &i.outhash_null;
    n++;

    // outindex_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.outindex_value;
    b[n].is_null = &i.outindex_null;
    n++;

    // script_
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.script_value.data ();
    b[n].size = &i.script_size;
    b[n].capacity = i.script_value.capacity ();
    b[n].is_null = &i.script_null;
    n++;

    // sequence_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.sequence_value;
    b[n].is_null = &i.sequence_null;
    n++;

    // tx_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.tx_value;
    b[n].is_null = &i.tx_null;
    n++;

    // txindex_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.txindex_value;
    b[n].is_null = &i.txindex_null;
    n++;

    // outpoint_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.outpoint_value;
    b[n].is_null = &i.outpoint_null;
    n++;
  }

  void access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::
  init (image_type& i,
        const object_type& o,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // id_
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.id_;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        v);
      i.id_null = is_null;
    }

    // outhash_
    //
    {
      ::bytes_t const& v =
        o.outhash_;

      bool is_null (false);
      std::size_t cap (i.outhash_value.capacity ());
      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_image (
        i.outhash_value,
        i.outhash_size,
        is_null,
        v);
      i.outhash_null = is_null;
      grew = grew || (cap != i.outhash_value.capacity ());
    }

    // outindex_
    //
    {
      ::uint32_t const& v =
        o.outindex_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_image (
        i.outindex_value,
        is_null,
        v);
      i.outindex_null = is_null;
    }

    // script_
    //
    {
      ::bytes_t const& v =
        o.script_;

      bool is_null (false);
      std::size_t cap (i.script_value.capacity ());
      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_image (
        i.script_value,
        i.script_size,
        is_null,
        v);
      i.script_null = is_null;
      grew = grew || (cap != i.script_value.capacity ());
    }

    // sequence_
    //
    {
      ::uint32_t const& v =
        o.sequence_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_image (
        i.sequence_value,
        is_null,
        v);
      i.sequence_null = is_null;
    }

    // tx_
    //
    {
      ::std::weak_ptr< ::CoinDB::Tx > const& v =
        o.tx_;

      typedef object_traits< ::CoinDB::Tx > obj_traits;
      typedef odb::pointer_traits< ::std::weak_ptr< ::CoinDB::Tx > > wptr_traits;
      typedef odb::pointer_traits< wptr_traits::strong_pointer_type > ptr_traits;

      wptr_traits::strong_pointer_type sp (wptr_traits::lock (v));
      bool is_null (ptr_traits::null_ptr (sp));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (sp)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.tx_value,
          is_null,
          id);
        i.tx_null = is_null;
      }
      else
        throw null_pointer ();
    }

    // txindex_
    //
    {
      ::uint32_t const& v =
        o.txindex_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_image (
        i.txindex_value,
        is_null,
        v);
      i.txindex_null = is_null;
    }

    // outpoint_
    //
    {
      ::std::weak_ptr< ::CoinDB::TxOut > const& v =
        o.outpoint_;

      typedef object_traits< ::CoinDB::TxOut > obj_traits;
      typedef odb::pointer_traits< ::std::weak_ptr< ::CoinDB::TxOut > > wptr_traits;
      typedef odb::pointer_traits< wptr_traits::strong_pointer_type > ptr_traits;

      wptr_traits::strong_pointer_type sp (wptr_traits::lock (v));
      bool is_null (ptr_traits::null_ptr (sp));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (sp)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.outpoint_value,
          is_null,
          id);
        i.outpoint_null = is_null;
      }
      else
        i.outpoint_null = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id_
    //
    {
      long unsigned int& v =
        o.id_;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // outhash_
    //
    {
      ::bytes_t& v =
        o.outhash_;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.outhash_value,
        i.outhash_size,
        i.outhash_null);
    }

    // outindex_
    //
    {
      ::uint32_t& v =
        o.outindex_;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.outindex_value,
        i.outindex_null);
    }

    // script_
    //
    {
      ::bytes_t& v =
        o.script_;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.script_value,
        i.script_size,
        i.script_null);
    }

    // sequence_
    //
    {
      ::uint32_t& v =
        o.sequence_;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.sequence_value,
        i.sequence_null);
    }

    // tx_
    //
    {
      ::std::weak_ptr< ::CoinDB::Tx >& v =
        o.tx_;

      typedef object_traits< ::CoinDB::Tx > obj_traits;
      typedef odb::pointer_traits< ::std::weak_ptr< ::CoinDB::Tx > > ptr_traits;

      if (i.tx_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.tx_value,
          i.tx_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));

        if (odb::pointer_traits<ptr_traits::strong_pointer_type>::null_ptr (
              ptr_traits::lock (v)))
          throw session_required ();
      }
    }

    // txindex_
    //
    {
      ::uint32_t& v =
        o.txindex_;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.txindex_value,
        i.txindex_null);
    }

    // outpoint_
    //
    {
      ::std::weak_ptr< ::CoinDB::TxOut >& v =
        o.outpoint_;

      typedef object_traits< ::CoinDB::TxOut > obj_traits;
      typedef odb::pointer_traits< ::std::weak_ptr< ::CoinDB::TxOut > > ptr_traits;

      if (i.outpoint_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.outpoint_value,
          i.outpoint_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));

        if (odb::pointer_traits<ptr_traits::strong_pointer_type>::null_ptr (
              ptr_traits::lock (v)))
          throw session_required ();
      }
    }
  }

  void access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::persist_statement[] =
  "INSERT INTO \"TxIn\" "
  "(\"id\", "
  "\"outhash\", "
  "\"outindex\", "
  "\"script\", "
  "\"sequence\", "
  "\"tx\", "
  "\"txindex\", "
  "\"outpoint\") "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::find_statement[] =
  "SELECT "
  "\"TxIn\".\"id\", "
  "\"TxIn\".\"outhash\", "
  "\"TxIn\".\"outindex\", "
  "\"TxIn\".\"script\", "
  "\"TxIn\".\"sequence\", "
  "\"TxIn\".\"tx\", "
  "\"TxIn\".\"txindex\", "
  "\"TxIn\".\"outpoint\" "
  "FROM \"TxIn\" "
  "WHERE \"TxIn\".\"id\"=?";

  const char access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::update_statement[] =
  "UPDATE \"TxIn\" "
  "SET "
  "\"outhash\"=?, "
  "\"outindex\"=?, "
  "\"script\"=?, "
  "\"sequence\"=?, "
  "\"tx\"=?, "
  "\"txindex\"=?, "
  "\"outpoint\"=? "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::erase_statement[] =
  "DELETE FROM \"TxIn\" "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::query_statement[] =
  "SELECT\n"
  "\"TxIn\".\"id\",\n"
  "\"TxIn\".\"outhash\",\n"
  "\"TxIn\".\"outindex\",\n"
  "\"TxIn\".\"script\",\n"
  "\"TxIn\".\"sequence\",\n"
  "\"TxIn\".\"tx\",\n"
  "\"TxIn\".\"txindex\",\n"
  "\"TxIn\".\"outpoint\"\n"
  "FROM \"TxIn\"\n"
  "LEFT JOIN \"Tx\" AS \"tx\" ON \"tx\".\"id\"=\"TxIn\".\"tx\"\n"
  "LEFT JOIN \"TxOut\" AS \"outpoint\" ON \"outpoint\".\"id\"=\"TxIn\".\"outpoint\"";

  const char access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"TxIn\"";

  const char access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::table_name[] =
  "\"TxIn\"";

  void access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id_ = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;
    using sqlite::update_statement;

    callback (db, obj, callback_event::pre_update);

    sqlite::transaction& tr (sqlite::transaction::current ());
    sqlite::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id_);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::pointer_type
  access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id_);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::object_type >
  access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += "\n";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        true,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::CoinDB::TxIn, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // TxOut
  //

  const char alias_traits<  ::CoinDB::Tx,
    id_sqlite,
    access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::tx_tag>::
  table_name[] = "\"tx\"";

  const char alias_traits<  ::CoinDB::TxIn,
    id_sqlite,
    access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::spent_tag>::
  table_name[] = "\"spent\"";

  const char alias_traits<  ::CoinDB::Account,
    id_sqlite,
    access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::sending_account_tag>::
  table_name[] = "\"sending_account\"";

  const char alias_traits<  ::CoinDB::Account,
    id_sqlite,
    access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::receiving_account_tag>::
  table_name[] = "\"receiving_account\"";

  const char alias_traits<  ::CoinDB::AccountBin,
    id_sqlite,
    access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::account_bin_tag>::
  table_name[] = "\"account_bin\"";

  const char alias_traits<  ::CoinDB::SigningScript,
    id_sqlite,
    access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::signingscript_tag>::
  table_name[] = "\"signingscript\"";

  struct access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::extra_statement_cache_type
  {
    extra_statement_cache_type (
      sqlite::connection&,
      image_type&,
      sqlite::binding&,
      sqlite::binding&)
    {
    }
  };

  access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::id_type
  access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id_
    //
    t[0UL] = false;

    // value_
    //
    t[1UL] = false;

    // script_
    //
    if (t[2UL])
    {
      i.script_value.capacity (i.script_size);
      grew = true;
    }

    // tx_
    //
    t[3UL] = false;

    // txindex_
    //
    t[4UL] = false;

    // spent_
    //
    t[5UL] = false;

    // sending_account_
    //
    t[6UL] = false;

    // sending_label_
    //
    if (t[7UL])
    {
      i.sending_label_value.capacity (i.sending_label_size);
      grew = true;
    }

    // receiving_account_
    //
    t[8UL] = false;

    // receiving_label_
    //
    if (t[9UL])
    {
      i.receiving_label_value.capacity (i.receiving_label_size);
      grew = true;
    }

    // account_bin_
    //
    t[10UL] = false;

    // signingscript_
    //
    t[11UL] = false;

    // status_
    //
    t[12UL] = false;

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // id_
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // value_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.value_value;
    b[n].is_null = &i.value_null;
    n++;

    // script_
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.script_value.data ();
    b[n].size = &i.script_size;
    b[n].capacity = i.script_value.capacity ();
    b[n].is_null = &i.script_null;
    n++;

    // tx_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.tx_value;
    b[n].is_null = &i.tx_null;
    n++;

    // txindex_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.txindex_value;
    b[n].is_null = &i.txindex_null;
    n++;

    // spent_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.spent_value;
    b[n].is_null = &i.spent_null;
    n++;

    // sending_account_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.sending_account_value;
    b[n].is_null = &i.sending_account_null;
    n++;

    // sending_label_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.sending_label_value.data ();
    b[n].size = &i.sending_label_size;
    b[n].capacity = i.sending_label_value.capacity ();
    b[n].is_null = &i.sending_label_null;
    n++;

    // receiving_account_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.receiving_account_value;
    b[n].is_null = &i.receiving_account_null;
    n++;

    // receiving_label_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.receiving_label_value.data ();
    b[n].size = &i.receiving_label_size;
    b[n].capacity = i.receiving_label_value.capacity ();
    b[n].is_null = &i.receiving_label_null;
    n++;

    // account_bin_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.account_bin_value;
    b[n].is_null = &i.account_bin_null;
    n++;

    // signingscript_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.signingscript_value;
    b[n].is_null = &i.signingscript_null;
    n++;

    // status_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.status_value;
    b[n].is_null = &i.status_null;
    n++;
  }

  void access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::
  init (image_type& i,
        const object_type& o,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // id_
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.id_;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        v);
      i.id_null = is_null;
    }

    // value_
    //
    {
      ::uint64_t const& v =
        o.value_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint64_t,
          sqlite::id_integer >::set_image (
        i.value_value,
        is_null,
        v);
      i.value_null = is_null;
    }

    // script_
    //
    {
      ::bytes_t const& v =
        o.script_;

      bool is_null (false);
      std::size_t cap (i.script_value.capacity ());
      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_image (
        i.script_value,
        i.script_size,
        is_null,
        v);
      i.script_null = is_null;
      grew = grew || (cap != i.script_value.capacity ());
    }

    // tx_
    //
    {
      ::std::weak_ptr< ::CoinDB::Tx > const& v =
        o.tx_;

      typedef object_traits< ::CoinDB::Tx > obj_traits;
      typedef odb::pointer_traits< ::std::weak_ptr< ::CoinDB::Tx > > wptr_traits;
      typedef odb::pointer_traits< wptr_traits::strong_pointer_type > ptr_traits;

      wptr_traits::strong_pointer_type sp (wptr_traits::lock (v));
      bool is_null (ptr_traits::null_ptr (sp));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (sp)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.tx_value,
          is_null,
          id);
        i.tx_null = is_null;
      }
      else
        throw null_pointer ();
    }

    // txindex_
    //
    {
      ::uint32_t const& v =
        o.txindex_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_image (
        i.txindex_value,
        is_null,
        v);
      i.txindex_null = is_null;
    }

    // spent_
    //
    {
      ::std::shared_ptr< ::CoinDB::TxIn > const& v =
        o.spent_;

      typedef object_traits< ::CoinDB::TxIn > obj_traits;
      typedef odb::pointer_traits< ::std::shared_ptr< ::CoinDB::TxIn > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.spent_value,
          is_null,
          id);
        i.spent_null = is_null;
      }
      else
        i.spent_null = true;
    }

    // sending_account_
    //
    {
      ::std::shared_ptr< ::CoinDB::Account > const& v =
        o.sending_account_;

      typedef object_traits< ::CoinDB::Account > obj_traits;
      typedef odb::pointer_traits< ::std::shared_ptr< ::CoinDB::Account > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.sending_account_value,
          is_null,
          id);
        i.sending_account_null = is_null;
      }
      else
        i.sending_account_null = true;
    }

    // sending_label_
    //
    {
      ::std::string const& v =
        o.sending_label_;

      bool is_null (false);
      std::size_t cap (i.sending_label_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.sending_label_value,
        i.sending_label_size,
        is_null,
        v);
      i.sending_label_null = is_null;
      grew = grew || (cap != i.sending_label_value.capacity ());
    }

    // receiving_account_
    //
    {
      ::std::shared_ptr< ::CoinDB::Account > const& v =
        o.receiving_account_;

      typedef object_traits< ::CoinDB::Account > obj_traits;
      typedef odb::pointer_traits< ::std::shared_ptr< ::CoinDB::Account > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.receiving_account_value,
          is_null,
          id);
        i.receiving_account_null = is_null;
      }
      else
        i.receiving_account_null = true;
    }

    // receiving_label_
    //
    {
      ::std::string const& v =
        o.receiving_label_;

      bool is_null (false);
      std::size_t cap (i.receiving_label_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.receiving_label_value,
        i.receiving_label_size,
        is_null,
        v);
      i.receiving_label_null = is_null;
      grew = grew || (cap != i.receiving_label_value.capacity ());
    }

    // account_bin_
    //
    {
      ::std::shared_ptr< ::CoinDB::AccountBin > const& v =
        o.account_bin_;

      typedef object_traits< ::CoinDB::AccountBin > obj_traits;
      typedef odb::pointer_traits< ::std::shared_ptr< ::CoinDB::AccountBin > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.account_bin_value,
          is_null,
          id);
        i.account_bin_null = is_null;
      }
      else
        i.account_bin_null = true;
    }

    // signingscript_
    //
    {
      ::std::shared_ptr< ::CoinDB::SigningScript > const& v =
        o.signingscript_;

      typedef object_traits< ::CoinDB::SigningScript > obj_traits;
      typedef odb::pointer_traits< ::std::shared_ptr< ::CoinDB::SigningScript > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.signingscript_value,
          is_null,
          id);
        i.signingscript_null = is_null;
      }
      else
        i.signingscript_null = true;
    }

    // status_
    //
    {
      ::CoinDB::TxOut::status_t const& v =
        o.status_;

      bool is_null (false);
      sqlite::value_traits<
          ::CoinDB::TxOut::status_t,
          sqlite::id_integer >::set_image (
        i.status_value,
        is_null,
        v);
      i.status_null = is_null;
    }

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id_
    //
    {
      long unsigned int& v =
        o.id_;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // value_
    //
    {
      ::uint64_t& v =
        o.value_;

      sqlite::value_traits<
          ::uint64_t,
          sqlite::id_integer >::set_value (
        v,
        i.value_value,
        i.value_null);
    }

    // script_
    //
    {
      ::bytes_t& v =
        o.script_;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.script_value,
        i.script_size,
        i.script_null);
    }

    // tx_
    //
    {
      ::std::weak_ptr< ::CoinDB::Tx >& v =
        o.tx_;

      typedef object_traits< ::CoinDB::Tx > obj_traits;
      typedef odb::pointer_traits< ::std::weak_ptr< ::CoinDB::Tx > > ptr_traits;

      if (i.tx_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.tx_value,
          i.tx_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));

        if (odb::pointer_traits<ptr_traits::strong_pointer_type>::null_ptr (
              ptr_traits::lock (v)))
          throw session_required ();
      }
    }

    // txindex_
    //
    {
      ::uint32_t& v =
        o.txindex_;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.txindex_value,
        i.txindex_null);
    }

    // spent_
    //
    {
      ::std::shared_ptr< ::CoinDB::TxIn >& v =
        o.spent_;

      typedef object_traits< ::CoinDB::TxIn > obj_traits;
      typedef odb::pointer_traits< ::std::shared_ptr< ::CoinDB::TxIn > > ptr_traits;

      if (i.spent_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.spent_value,
          i.spent_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // sending_account_
    //
    {
      ::std::shared_ptr< ::CoinDB::Account >& v =
        o.sending_account_;

      typedef object_traits< ::CoinDB::Account > obj_traits;
      typedef odb::pointer_traits< ::std::shared_ptr< ::CoinDB::Account > > ptr_traits;

      if (i.sending_account_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.sending_account_value,
          i.sending_account_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // sending_label_
    //
    {
      ::std::string& v =
        o.sending_label_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.sending_label_value,
        i.sending_label_size,
        i.sending_label_null);
    }

    // receiving_account_
    //
    {
      ::std::shared_ptr< ::CoinDB::Account >& v =
        o.receiving_account_;

      typedef object_traits< ::CoinDB::Account > obj_traits;
      typedef odb::pointer_traits< ::std::shared_ptr< ::CoinDB::Account > > ptr_traits;

      if (i.receiving_account_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.receiving_account_value,
          i.receiving_account_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // receiving_label_
    //
    {
      ::std::string& v =
        o.receiving_label_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.receiving_label_value,
        i.receiving_label_size,
        i.receiving_label_null);
    }

    // account_bin_
    //
    {
      ::std::shared_ptr< ::CoinDB::AccountBin >& v =
        o.account_bin_;

      typedef object_traits< ::CoinDB::AccountBin > obj_traits;
      typedef odb::pointer_traits< ::std::shared_ptr< ::CoinDB::AccountBin > > ptr_traits;

      if (i.account_bin_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.account_bin_value,
          i.account_bin_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // signingscript_
    //
    {
      ::std::shared_ptr< ::CoinDB::SigningScript >& v =
        o.signingscript_;

      typedef object_traits< ::CoinDB::SigningScript > obj_traits;
      typedef odb::pointer_traits< ::std::shared_ptr< ::CoinDB::SigningScript > > ptr_traits;

      if (i.signingscript_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.signingscript_value,
          i.signingscript_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // status_
    //
    {
      ::CoinDB::TxOut::status_t& v =
        o.status_;

      sqlite::value_traits<
          ::CoinDB::TxOut::status_t,
          sqlite::id_integer >::set_value (
        v,
        i.status_value,
        i.status_null);
    }
  }

  void access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::persist_statement[] =
  "INSERT INTO \"TxOut\" "
  "(\"id\", "
  "\"value\", "
  "\"script\", "
  "\"tx\", "
  "\"txindex\", "
  "\"spent\", "
  "\"sending_account\", "
  "\"sending_label\", "
  "\"receiving_account\", "
  "\"receiving_label\", "
  "\"account_bin\", "
  "\"signingscript\", "
  "\"status\") "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::find_statement[] =
  "SELECT "
  "\"TxOut\".\"id\", "
  "\"TxOut\".\"value\", "
  "\"TxOut\".\"script\", "
  "\"TxOut\".\"tx\", "
  "\"TxOut\".\"txindex\", "
  "\"TxOut\".\"spent\", "
  "\"TxOut\".\"sending_account\", "
  "\"TxOut\".\"sending_label\", "
  "\"TxOut\".\"receiving_account\", "
  "\"TxOut\".\"receiving_label\", "
  "\"TxOut\".\"account_bin\", "
  "\"TxOut\".\"signingscript\", "
  "\"TxOut\".\"status\" "
  "FROM \"TxOut\" "
  "WHERE \"TxOut\".\"id\"=?";

  const char access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::update_statement[] =
  "UPDATE \"TxOut\" "
  "SET "
  "\"value\"=?, "
  "\"script\"=?, "
  "\"tx\"=?, "
  "\"txindex\"=?, "
  "\"spent\"=?, "
  "\"sending_account\"=?, "
  "\"sending_label\"=?, "
  "\"receiving_account\"=?, "
  "\"receiving_label\"=?, "
  "\"account_bin\"=?, "
  "\"signingscript\"=?, "
  "\"status\"=? "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::erase_statement[] =
  "DELETE FROM \"TxOut\" "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::query_statement[] =
  "SELECT\n"
  "\"TxOut\".\"id\",\n"
  "\"TxOut\".\"value\",\n"
  "\"TxOut\".\"script\",\n"
  "\"TxOut\".\"tx\",\n"
  "\"TxOut\".\"txindex\",\n"
  "\"TxOut\".\"spent\",\n"
  "\"TxOut\".\"sending_account\",\n"
  "\"TxOut\".\"sending_label\",\n"
  "\"TxOut\".\"receiving_account\",\n"
  "\"TxOut\".\"receiving_label\",\n"
  "\"TxOut\".\"account_bin\",\n"
  "\"TxOut\".\"signingscript\",\n"
  "\"TxOut\".\"status\"\n"
  "FROM \"TxOut\"\n"
  "LEFT JOIN \"Tx\" AS \"tx\" ON \"tx\".\"id\"=\"TxOut\".\"tx\"\n"
  "LEFT JOIN \"TxIn\" AS \"spent\" ON \"spent\".\"id\"=\"TxOut\".\"spent\"\n"
  "LEFT JOIN \"Account\" AS \"sending_account\" ON \"sending_account\".\"id\"=\"TxOut\".\"sending_account\"\n"
  "LEFT JOIN \"Account\" AS \"receiving_account\" ON \"receiving_account\".\"id\"=\"TxOut\".\"receiving_account\"\n"
  "LEFT JOIN \"AccountBin\" AS \"account_bin\" ON \"account_bin\".\"id\"=\"TxOut\".\"account_bin\"\n"
  "LEFT JOIN \"SigningScript\" AS \"signingscript\" ON \"signingscript\".\"id\"=\"TxOut\".\"signingscript\"";

  const char access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"TxOut\"";

  const char access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::table_name[] =
  "\"TxOut\"";

  void access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id_ = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;
    using sqlite::update_statement;

    callback (db, obj, callback_event::pre_update);

    sqlite::transaction& tr (sqlite::transaction::current ());
    sqlite::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id_);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::pointer_type
  access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id_);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  result< access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::object_type >
  access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += "\n";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        true,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::CoinDB::TxOut, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // Tx
  //

  const char alias_traits<  ::CoinDB::BlockHeader,
    id_sqlite,
    access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::blockheader_tag>::
  table_name[] = "\"blockheader\"";

  const char alias_traits<  ::CoinDB::User,
    id_sqlite,
    access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::user_tag>::
  table_name[] = "\"user\"";

  struct access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::extra_statement_cache_type
  {
    sqlite::container_statements_impl< txins_traits > txins_;
    sqlite::container_statements_impl< txouts_traits > txouts_;

    extra_statement_cache_type (
      sqlite::connection& c,
      image_type&,
      sqlite::binding& id,
      sqlite::binding&)
    : txins_ (c, id),
      txouts_ (c, id)
    {
    }
  };

  // txins_
  //

  const char access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::txins_traits::
  select_statement[] =
  "SELECT "
  "\"TxIn\".\"id\" "
  "FROM \"TxIn\" "
  "WHERE \"TxIn\".\"tx\"=?";

  const char access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::txins_traits::
  insert_statement[] =
  "";

  const char access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::txins_traits::
  delete_statement[] =
  "";

  void access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::txins_traits::
  bind (sqlite::bind* b,
        const sqlite::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace sqlite;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // value
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &d.value_value;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::txins_traits::
  grow (data_image_type& i,
        bool* t)
  {
    bool grew (false);

    // value
    //
    t[0UL] = false;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::txins_traits::
  init (value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // value
    //
    {
      typedef object_traits< ::CoinDB::TxIn > obj_traits;
      typedef odb::pointer_traits< value_type > ptr_traits;

      if (i.value_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.value_value,
          i.value_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }
  }

  void access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::txins_traits::
  insert (index_type, const value_type&, void*)
  {
  }

  bool access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::txins_traits::
  select (index_type&, value_type& v, void* d)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (v, di, &sts.connection ().database ());

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());
    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::txins_traits::
  delete_ (void*)
  {
  }

  void access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::txins_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());
    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = false;
    container_traits_type::load (c, more, fs);
  }

  // txouts_
  //

  const char access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::txouts_traits::
  select_statement[] =
  "SELECT "
  "\"TxOut\".\"id\" "
  "FROM \"TxOut\" "
  "WHERE \"TxOut\".\"tx\"=?";

  const char access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::txouts_traits::
  insert_statement[] =
  "";

  const char access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::txouts_traits::
  delete_statement[] =
  "";

  void access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::txouts_traits::
  bind (sqlite::bind* b,
        const sqlite::bind* id,
        std::size_t id_size,
        data_image_type& d)
  {
    using namespace sqlite;

    statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    size_t n (0);

    // object_id
    //
    if (id != 0)
      std::memcpy (&b[n], id, id_size * sizeof (id[0]));
    n += id_size;

    // value
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &d.value_value;
    b[n].is_null = &d.value_null;
  }

  void access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::txouts_traits::
  grow (data_image_type& i,
        bool* t)
  {
    bool grew (false);

    // value
    //
    t[0UL] = false;

    if (grew)
      i.version++;
  }

  void access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::txouts_traits::
  init (value_type& v,
        const data_image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (db);

    // value
    //
    {
      typedef object_traits< ::CoinDB::TxOut > obj_traits;
      typedef odb::pointer_traits< value_type > ptr_traits;

      if (i.value_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.value_value,
          i.value_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }
  }

  void access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::txouts_traits::
  insert (index_type, const value_type&, void*)
  {
  }

  bool access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::txouts_traits::
  select (index_type&, value_type& v, void* d)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    statements_type& sts (*static_cast< statements_type* > (d));
    data_image_type& di (sts.data_image ());

    init (v, di, &sts.connection ().database ());

    if (sts.data_binding_test_version ())
    {
      const binding& id (sts.id_binding ());
      bind (sts.data_bind (), id.bind, id.count, di);
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    select_statement::result r (st.fetch ());
    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::txouts_traits::
  delete_ (void*)
  {
  }

  void access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::txouts_traits::
  load (container_type& c,
        statements_type& sts)
  {
    using namespace sqlite;
    using sqlite::select_statement;

    const binding& id (sts.id_binding ());

    if (sts.data_binding_test_version ())
    {
      bind (sts.data_bind (), id.bind, id.count, sts.data_image ());
      sts.data_binding_update_version ();
    }

    select_statement& st (sts.select_statement ());
    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());
    bool more (r != select_statement::no_data);

    functions_type& fs (sts.functions ());
    fs.ordered_ = false;
    container_traits_type::load (c, more, fs);
  }

  access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::id_type
  access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::
  id (const image_type& i)
  {
    sqlite::database* db (0);
    ODB_POTENTIALLY_UNUSED (db);

    id_type id;
    {
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        id,
        i.id_value,
        i.id_null);
    }

    return id;
  }

  bool access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id_
    //
    t[0UL] = false;

    // hash_
    //
    if (t[1UL])
    {
      i.hash_value.capacity (i.hash_size);
      grew = true;
    }

    // unsigned_hash_
    //
    if (t[2UL])
    {
      i.unsigned_hash_value.capacity (i.unsigned_hash_size);
      grew = true;
    }

    // version_
    //
    t[3UL] = false;

    // locktime_
    //
    t[4UL] = false;

    // timestamp_
    //
    t[5UL] = false;

    // status_
    //
    t[6UL] = false;

    // conflicting_
    //
    t[7UL] = false;

    // have_all_outpoints_
    //
    t[8UL] = false;

    // txin_total_
    //
    t[9UL] = false;

    // txout_total_
    //
    t[10UL] = false;

    // blockheader_
    //
    t[11UL] = false;

    // blockindex_
    //
    t[12UL] = false;

    // user_
    //
    t[13UL] = false;

    // propagation_protocol_
    //
    if (t[14UL])
    {
      i.propagation_protocol_value.capacity (i.propagation_protocol_size);
      grew = true;
    }

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    std::size_t n (0);

    // id_
    //
    if (sk != statement_update)
    {
      b[n].type = sqlite::bind::integer;
      b[n].buffer = &i.id_value;
      b[n].is_null = &i.id_null;
      n++;
    }

    // hash_
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.hash_value.data ();
    b[n].size = &i.hash_size;
    b[n].capacity = i.hash_value.capacity ();
    b[n].is_null = &i.hash_null;
    n++;

    // unsigned_hash_
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.unsigned_hash_value.data ();
    b[n].size = &i.unsigned_hash_size;
    b[n].capacity = i.unsigned_hash_value.capacity ();
    b[n].is_null = &i.unsigned_hash_null;
    n++;

    // version_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.version_value;
    b[n].is_null = &i.version_null;
    n++;

    // locktime_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.locktime_value;
    b[n].is_null = &i.locktime_null;
    n++;

    // timestamp_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.timestamp_value;
    b[n].is_null = &i.timestamp_null;
    n++;

    // status_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.status_value;
    b[n].is_null = &i.status_null;
    n++;

    // conflicting_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.conflicting_value;
    b[n].is_null = &i.conflicting_null;
    n++;

    // have_all_outpoints_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.have_all_outpoints_value;
    b[n].is_null = &i.have_all_outpoints_null;
    n++;

    // txin_total_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.txin_total_value;
    b[n].is_null = &i.txin_total_null;
    n++;

    // txout_total_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.txout_total_value;
    b[n].is_null = &i.txout_total_null;
    n++;

    // blockheader_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.blockheader_value;
    b[n].is_null = &i.blockheader_null;
    n++;

    // blockindex_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.blockindex_value;
    b[n].is_null = &i.blockindex_null;
    n++;

    // user_
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.user_value;
    b[n].is_null = &i.user_null;
    n++;

    // propagation_protocol_
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.propagation_protocol_value.data ();
    b[n].size = &i.propagation_protocol_size;
    b[n].capacity = i.propagation_protocol_value.capacity ();
    b[n].is_null = &i.propagation_protocol_null;
    n++;
  }

  void access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::
  bind (sqlite::bind* b, id_image_type& i)
  {
    std::size_t n (0);
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
  }

  bool access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::
  init (image_type& i,
        const object_type& o,
        sqlite::statement_kind sk)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (sk);

    using namespace sqlite;

    bool grew (false);

    // id_
    //
    if (sk == statement_insert)
    {
      long unsigned int const& v =
        o.id_;

      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        v);
      i.id_null = is_null;
    }

    // hash_
    //
    {
      ::bytes_t const& v =
        o.hash_;

      bool is_null (false);
      std::size_t cap (i.hash_value.capacity ());
      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_image (
        i.hash_value,
        i.hash_size,
        is_null,
        v);
      i.hash_null = is_null;
      grew = grew || (cap != i.hash_value.capacity ());
    }

    // unsigned_hash_
    //
    {
      ::bytes_t const& v =
        o.unsigned_hash_;

      bool is_null (false);
      std::size_t cap (i.unsigned_hash_value.capacity ());
      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_image (
        i.unsigned_hash_value,
        i.unsigned_hash_size,
        is_null,
        v);
      i.unsigned_hash_null = is_null;
      grew = grew || (cap != i.unsigned_hash_value.capacity ());
    }

    // version_
    //
    {
      ::uint32_t const& v =
        o.version_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_image (
        i.version_value,
        is_null,
        v);
      i.version_null = is_null;
    }

    // locktime_
    //
    {
      ::uint32_t const& v =
        o.locktime_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_image (
        i.locktime_value,
        is_null,
        v);
      i.locktime_null = is_null;
    }

    // timestamp_
    //
    {
      ::uint32_t const& v =
        o.timestamp_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_image (
        i.timestamp_value,
        is_null,
        v);
      i.timestamp_null = is_null;
    }

    // status_
    //
    {
      ::CoinDB::Tx::status_t const& v =
        o.status_;

      bool is_null (false);
      sqlite::value_traits<
          ::CoinDB::Tx::status_t,
          sqlite::id_integer >::set_image (
        i.status_value,
        is_null,
        v);
      i.status_null = is_null;
    }

    // conflicting_
    //
    {
      bool const& v =
        o.conflicting_;

      bool is_null (false);
      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_image (
        i.conflicting_value,
        is_null,
        v);
      i.conflicting_null = is_null;
    }

    // have_all_outpoints_
    //
    {
      bool const& v =
        o.have_all_outpoints_;

      bool is_null (false);
      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_image (
        i.have_all_outpoints_value,
        is_null,
        v);
      i.have_all_outpoints_null = is_null;
    }

    // txin_total_
    //
    {
      ::uint64_t const& v =
        o.txin_total_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint64_t,
          sqlite::id_integer >::set_image (
        i.txin_total_value,
        is_null,
        v);
      i.txin_total_null = is_null;
    }

    // txout_total_
    //
    {
      ::uint64_t const& v =
        o.txout_total_;

      bool is_null (false);
      sqlite::value_traits<
          ::uint64_t,
          sqlite::id_integer >::set_image (
        i.txout_total_value,
        is_null,
        v);
      i.txout_total_null = is_null;
    }

    // blockheader_
    //
    {
      ::std::shared_ptr< ::CoinDB::BlockHeader > const& v =
        o.blockheader_;

      typedef object_traits< ::CoinDB::BlockHeader > obj_traits;
      typedef odb::pointer_traits< ::std::shared_ptr< ::CoinDB::BlockHeader > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.blockheader_value,
          is_null,
          id);
        i.blockheader_null = is_null;
      }
      else
        i.blockheader_null = true;
    }

    // blockindex_
    //
    {
      ::odb::nullable< unsigned int > const& v =
        o.blockindex_;

      bool is_null (true);
      sqlite::value_traits<
          ::odb::nullable< unsigned int >,
          sqlite::id_integer >::set_image (
        i.blockindex_value,
        is_null,
        v);
      i.blockindex_null = is_null;
    }

    // user_
    //
    {
      ::std::shared_ptr< ::CoinDB::User > const& v =
        o.user_;

      typedef object_traits< ::CoinDB::User > obj_traits;
      typedef odb::pointer_traits< ::std::shared_ptr< ::CoinDB::User > > ptr_traits;

      bool is_null (ptr_traits::null_ptr (v));
      if (!is_null)
      {
        const obj_traits::id_type& id (
          obj_traits::id (ptr_traits::get_ref (v)));

        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_image (
          i.user_value,
          is_null,
          id);
        i.user_null = is_null;
      }
      else
        i.user_null = true;
    }

    // propagation_protocol_
    //
    {
      ::std::string const& v =
        o.propagation_protocol_;

      bool is_null (false);
      std::size_t cap (i.propagation_protocol_value.capacity ());
      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_image (
        i.propagation_protocol_value,
        i.propagation_protocol_size,
        is_null,
        v);
      i.propagation_protocol_null = is_null;
      grew = grew || (cap != i.propagation_protocol_value.capacity ());
    }

    return grew;
  }

  void access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::
  init (object_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id_
    //
    {
      long unsigned int& v =
        o.id_;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // hash_
    //
    {
      ::bytes_t& v =
        o.hash_;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.hash_value,
        i.hash_size,
        i.hash_null);
    }

    // unsigned_hash_
    //
    {
      ::bytes_t& v =
        o.unsigned_hash_;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.unsigned_hash_value,
        i.unsigned_hash_size,
        i.unsigned_hash_null);
    }

    // version_
    //
    {
      ::uint32_t& v =
        o.version_;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.version_value,
        i.version_null);
    }

    // locktime_
    //
    {
      ::uint32_t& v =
        o.locktime_;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.locktime_value,
        i.locktime_null);
    }

    // timestamp_
    //
    {
      ::uint32_t& v =
        o.timestamp_;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.timestamp_value,
        i.timestamp_null);
    }

    // status_
    //
    {
      ::CoinDB::Tx::status_t& v =
        o.status_;

      sqlite::value_traits<
          ::CoinDB::Tx::status_t,
          sqlite::id_integer >::set_value (
        v,
        i.status_value,
        i.status_null);
    }

    // conflicting_
    //
    {
      bool& v =
        o.conflicting_;

      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_value (
        v,
        i.conflicting_value,
        i.conflicting_null);
    }

    // have_all_outpoints_
    //
    {
      bool& v =
        o.have_all_outpoints_;

      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_value (
        v,
        i.have_all_outpoints_value,
        i.have_all_outpoints_null);
    }

    // txin_total_
    //
    {
      ::uint64_t& v =
        o.txin_total_;

      sqlite::value_traits<
          ::uint64_t,
          sqlite::id_integer >::set_value (
        v,
        i.txin_total_value,
        i.txin_total_null);
    }

    // txout_total_
    //
    {
      ::uint64_t& v =
        o.txout_total_;

      sqlite::value_traits<
          ::uint64_t,
          sqlite::id_integer >::set_value (
        v,
        i.txout_total_value,
        i.txout_total_null);
    }

    // blockheader_
    //
    {
      ::std::shared_ptr< ::CoinDB::BlockHeader >& v =
        o.blockheader_;

      typedef object_traits< ::CoinDB::BlockHeader > obj_traits;
      typedef odb::pointer_traits< ::std::shared_ptr< ::CoinDB::BlockHeader > > ptr_traits;

      if (i.blockheader_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.blockheader_value,
          i.blockheader_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // blockindex_
    //
    {
      ::odb::nullable< unsigned int >& v =
        o.blockindex_;

      sqlite::value_traits<
          ::odb::nullable< unsigned int >,
          sqlite::id_integer >::set_value (
        v,
        i.blockindex_value,
        i.blockindex_null);
    }

    // user_
    //
    {
      ::std::shared_ptr< ::CoinDB::User >& v =
        o.user_;

      typedef object_traits< ::CoinDB::User > obj_traits;
      typedef odb::pointer_traits< ::std::shared_ptr< ::CoinDB::User > > ptr_traits;

      if (i.user_null)
        v = ptr_traits::pointer_type ();
      else
      {
        obj_traits::id_type id;
        sqlite::value_traits<
            obj_traits::id_type,
            sqlite::id_integer >::set_value (
          id,
          i.user_value,
          i.user_null);

        // If a compiler error points to the line below, then
        // it most likely means that a pointer used in a member
        // cannot be initialized from an object pointer.
        //
        v = ptr_traits::pointer_type (
          static_cast<sqlite::database*> (db)->load<
            obj_traits::object_type > (id));
      }
    }

    // propagation_protocol_
    //
    {
      ::std::string& v =
        o.propagation_protocol_;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.propagation_protocol_value,
        i.propagation_protocol_size,
        i.propagation_protocol_null);
    }
  }

  void access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::
  init (id_image_type& i, const id_type& id)
  {
    {
      bool is_null (false);
      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_image (
        i.id_value,
        is_null,
        id);
      i.id_null = is_null;
    }
  }

  const char access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::persist_statement[] =
  "INSERT INTO \"Tx\" "
  "(\"id\", "
  "\"hash\", "
  "\"unsigned_hash\", "
  "\"version\", "
  "\"locktime\", "
  "\"timestamp\", "
  "\"status\", "
  "\"conflicting\", "
  "\"have_all_outpoints\", "
  "\"txin_total\", "
  "\"txout_total\", "
  "\"blockheader\", "
  "\"blockindex\", "
  "\"user\", "
  "\"propagation_protocol\") "
  "VALUES "
  "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";

  const char access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::find_statement[] =
  "SELECT "
  "\"Tx\".\"id\", "
  "\"Tx\".\"hash\", "
  "\"Tx\".\"unsigned_hash\", "
  "\"Tx\".\"version\", "
  "\"Tx\".\"locktime\", "
  "\"Tx\".\"timestamp\", "
  "\"Tx\".\"status\", "
  "\"Tx\".\"conflicting\", "
  "\"Tx\".\"have_all_outpoints\", "
  "\"Tx\".\"txin_total\", "
  "\"Tx\".\"txout_total\", "
  "\"Tx\".\"blockheader\", "
  "\"Tx\".\"blockindex\", "
  "\"Tx\".\"user\", "
  "\"Tx\".\"propagation_protocol\" "
  "FROM \"Tx\" "
  "WHERE \"Tx\".\"id\"=?";

  const char access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::update_statement[] =
  "UPDATE \"Tx\" "
  "SET "
  "\"hash\"=?, "
  "\"unsigned_hash\"=?, "
  "\"version\"=?, "
  "\"locktime\"=?, "
  "\"timestamp\"=?, "
  "\"status\"=?, "
  "\"conflicting\"=?, "
  "\"have_all_outpoints\"=?, "
  "\"txin_total\"=?, "
  "\"txout_total\"=?, "
  "\"blockheader\"=?, "
  "\"blockindex\"=?, "
  "\"user\"=?, "
  "\"propagation_protocol\"=? "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::erase_statement[] =
  "DELETE FROM \"Tx\" "
  "WHERE \"id\"=?";

  const char access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::query_statement[] =
  "SELECT\n"
  "\"Tx\".\"id\",\n"
  "\"Tx\".\"hash\",\n"
  "\"Tx\".\"unsigned_hash\",\n"
  "\"Tx\".\"version\",\n"
  "\"Tx\".\"locktime\",\n"
  "\"Tx\".\"timestamp\",\n"
  "\"Tx\".\"status\",\n"
  "\"Tx\".\"conflicting\",\n"
  "\"Tx\".\"have_all_outpoints\",\n"
  "\"Tx\".\"txin_total\",\n"
  "\"Tx\".\"txout_total\",\n"
  "\"Tx\".\"blockheader\",\n"
  "\"Tx\".\"blockindex\",\n"
  "\"Tx\".\"user\",\n"
  "\"Tx\".\"propagation_protocol\"\n"
  "FROM \"Tx\"\n"
  "LEFT JOIN \"BlockHeader\" AS \"blockheader\" ON \"blockheader\".\"id\"=\"Tx\".\"blockheader\"\n"
  "LEFT JOIN \"User\" AS \"user\" ON \"user\".\"id\"=\"Tx\".\"user\"";

  const char access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::erase_query_statement[] =
  "DELETE FROM \"Tx\"";

  const char access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::table_name[] =
  "\"Tx\"";

  void access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::
  persist (database& db, object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::pre_persist);

    image_type& im (sts.image ());
    binding& imb (sts.insert_image_binding ());

    if (init (im, obj, statement_insert))
      im.version++;

    im.id_null = true;

    if (im.version != sts.insert_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_insert);
      sts.insert_image_version (im.version);
      imb.version++;
    }

    insert_statement& st (sts.persist_statement ());
    if (!st.execute ())
      throw object_already_persistent ();

    obj.id_ = static_cast< id_type > (st.id ());

    callback (db,
              static_cast<const object_type&> (obj),
              callback_event::post_persist);
  }

  void access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::
  update (database& db, const object_type& obj)
  {
    ODB_POTENTIALLY_UNUSED (db);

    using namespace sqlite;
    using sqlite::update_statement;

    callback (db, obj, callback_event::pre_update);

    sqlite::transaction& tr (sqlite::transaction::current ());
    sqlite::connection& conn (tr.connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    const id_type& id (
      obj.id_);
    id_image_type& idi (sts.id_image ());
    init (idi, id);

    image_type& im (sts.image ());
    if (init (im, obj, statement_update))
      im.version++;

    bool u (false);
    binding& imb (sts.update_image_binding ());
    if (im.version != sts.update_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_update);
      sts.update_image_version (im.version);
      imb.version++;
      u = true;
    }

    binding& idb (sts.id_image_binding ());
    if (idi.version != sts.update_id_image_version () ||
        idb.version == 0)
    {
      if (idi.version != sts.id_image_version () ||
          idb.version == 0)
      {
        bind (idb.bind, idi);
        sts.id_image_version (idi.version);
        idb.version++;
      }

      sts.update_id_image_version (idi.version);

      if (!u)
        imb.version++;
    }

    update_statement& st (sts.update_statement ());
    if (st.execute () == 0)
      throw object_not_persistent ();

    callback (db, obj, callback_event::post_update);
    pointer_cache_traits::update (db, obj);
  }

  void access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::
  erase (database& db, const id_type& id)
  {
    using namespace sqlite;

    ODB_POTENTIALLY_UNUSED (db);

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    id_image_type& i (sts.id_image ());
    init (i, id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    if (sts.erase_statement ().execute () != 1)
      throw object_not_persistent ();

    pointer_cache_traits::erase (db, id);
  }

  access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::pointer_type
  access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::
  find (database& db, const id_type& id)
  {
    using namespace sqlite;

    {
      pointer_type p (pointer_cache_traits::find (db, id));

      if (!pointer_traits::null_ptr (p))
        return p;
    }

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (l.locked ())
    {
      if (!find_ (sts, &id))
        return pointer_type ();
    }

    pointer_type p (
      access::object_factory<object_type, pointer_type>::create ());
    pointer_traits::guard pg (p);

    pointer_cache_traits::insert_guard ig (
      pointer_cache_traits::insert (db, id, p));

    object_type& obj (pointer_traits::get_ref (p));

    if (l.locked ())
    {
      select_statement& st (sts.find_statement ());
      ODB_POTENTIALLY_UNUSED (st);

      callback (db, obj, callback_event::pre_load);
      init (obj, sts.image (), &db);
      load_ (sts, obj, false);
      sts.load_delayed (0);
      l.unlock ();
      callback (db, obj, callback_event::post_load);
      pointer_cache_traits::load (ig.position ());
    }
    else
      sts.delay_load (id, obj, ig.position ());

    ig.release ();
    pg.release ();
    return p;
  }

  bool access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::
  find (database& db, const id_type& id, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    reference_cache_traits::position_type pos (
      reference_cache_traits::insert (db, id, obj));
    reference_cache_traits::insert_guard ig (pos);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, false);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    reference_cache_traits::load (pos);
    ig.release ();
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::
  reload (database& db, object_type& obj)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    statements_type::auto_lock l (sts);

    const id_type& id  (
      obj.id_);

    if (!find_ (sts, &id))
      return false;

    select_statement& st (sts.find_statement ());
    ODB_POTENTIALLY_UNUSED (st);

    callback (db, obj, callback_event::pre_load);
    init (obj, sts.image (), &db);
    load_ (sts, obj, true);
    sts.load_delayed (0);
    l.unlock ();
    callback (db, obj, callback_event::post_load);
    return true;
  }

  bool access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::
  find_ (statements_type& sts,
         const id_type* id)
  {
    using namespace sqlite;

    id_image_type& i (sts.id_image ());
    init (i, *id);

    binding& idb (sts.id_image_binding ());
    if (i.version != sts.id_image_version () || idb.version == 0)
    {
      bind (idb.bind, i);
      sts.id_image_version (i.version);
      idb.version++;
    }

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    select_statement& st (sts.find_statement ());

    st.execute ();
    auto_result ar (st);
    select_statement::result r (st.fetch ());

    if (r == select_statement::truncated)
    {
      if (grow (im, sts.select_image_truncated ()))
        im.version++;

      if (im.version != sts.select_image_version ())
      {
        bind (imb.bind, im, statement_select);
        sts.select_image_version (im.version);
        imb.version++;
        st.refetch ();
      }
    }

    return r != select_statement::no_data;
  }

  void access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::
  load_ (statements_type& sts,
         object_type& obj,
         bool reload)
  {
    ODB_POTENTIALLY_UNUSED (reload);

    extra_statement_cache_type& esc (sts.extra_statement_cache ());

    // txins_
    //
    {
      ::CoinDB::txins_t& v =
        obj.txins_;

      txins_traits::load (
        v,
        esc.txins_);
    }

    // txouts_
    //
    {
      ::CoinDB::txouts_t& v =
        obj.txouts_;

      txouts_traits::load (
        v,
        esc.txouts_);
    }
  }

  result< access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::object_type >
  access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    statements_type& sts (
      conn.statement_cache ().find_object<object_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.select_image_binding ());

    if (im.version != sts.select_image_version () ||
        imb.version == 0)
    {
      bind (imb.bind, im, statement_select);
      sts.select_image_version (im.version);
      imb.version++;
    }

    std::string text (query_statement);
    if (!q.empty ())
    {
      text += "\n";
      text += q.clause ();
    }

    q.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        text,
        true,
        true,
        q.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::object_result_impl<object_type> > r (
      new (shared) sqlite::object_result_impl<object_type> (
        q, st, sts, 0));

    return result<object_type> (r);
  }

  unsigned long long access::object_traits_impl< ::CoinDB::Tx, id_sqlite >::
  erase_query (database&, const query_base_type& q)
  {
    using namespace sqlite;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());

    std::string text (erase_query_statement);
    if (!q.empty ())
    {
      text += ' ';
      text += q.clause ();
    }

    q.init_parameters ();
    delete_statement st (
      conn,
      text,
      q.parameters_binding ());

    return st.execute ();
  }

  // KeychainView
  //

  bool access::view_traits_impl< ::CoinDB::KeychainView, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = false;

    // name
    //
    if (t[1UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // depth
    //
    t[2UL] = false;

    // parent_fp
    //
    t[3UL] = false;

    // child_num
    //
    t[4UL] = false;

    // pubkey
    //
    if (t[5UL])
    {
      i.pubkey_value.capacity (i.pubkey_size);
      grew = true;
    }

    // hash
    //
    if (t[6UL])
    {
      i.hash_value.capacity (i.hash_size);
      grew = true;
    }

    // is_private
    //
    t[7UL] = false;

    // is_encrypted
    //
    t[8UL] = false;

    return grew;
  }

  void access::view_traits_impl< ::CoinDB::KeychainView, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i)
  {
    using namespace sqlite;

    sqlite::statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    std::size_t n (0);

    // id
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
    n++;

    // name
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.name_value.data ();
    b[n].size = &i.name_size;
    b[n].capacity = i.name_value.capacity ();
    b[n].is_null = &i.name_null;
    n++;

    // depth
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.depth_value;
    b[n].is_null = &i.depth_null;
    n++;

    // parent_fp
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.parent_fp_value;
    b[n].is_null = &i.parent_fp_null;
    n++;

    // child_num
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.child_num_value;
    b[n].is_null = &i.child_num_null;
    n++;

    // pubkey
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.pubkey_value.data ();
    b[n].size = &i.pubkey_size;
    b[n].capacity = i.pubkey_value.capacity ();
    b[n].is_null = &i.pubkey_null;
    n++;

    // hash
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.hash_value.data ();
    b[n].size = &i.hash_size;
    b[n].capacity = i.hash_value.capacity ();
    b[n].is_null = &i.hash_null;
    n++;

    // is_private
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.is_private_value;
    b[n].is_null = &i.is_private_null;
    n++;

    // is_encrypted
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.is_encrypted_value;
    b[n].is_null = &i.is_encrypted_null;
    n++;
  }

  void access::view_traits_impl< ::CoinDB::KeychainView, id_sqlite >::
  init (view_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      long unsigned int& v =
        o.id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // name
    //
    {
      ::std::string& v =
        o.name;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // depth
    //
    {
      ::uint32_t& v =
        o.depth;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.depth_value,
        i.depth_null);
    }

    // parent_fp
    //
    {
      ::uint32_t& v =
        o.parent_fp;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.parent_fp_value,
        i.parent_fp_null);
    }

    // child_num
    //
    {
      ::uint32_t& v =
        o.child_num;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.child_num_value,
        i.child_num_null);
    }

    // pubkey
    //
    {
      ::bytes_t& v =
        o.pubkey;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.pubkey_value,
        i.pubkey_size,
        i.pubkey_null);
    }

    // hash
    //
    {
      ::bytes_t& v =
        o.hash;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.hash_value,
        i.hash_size,
        i.hash_null);
    }

    // is_private
    //
    {
      bool& v =
        o.is_private;

      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_value (
        v,
        i.is_private_value,
        i.is_private_null);
    }

    // is_encrypted
    //
    {
      bool& v =
        o.is_encrypted;

      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_value (
        v,
        i.is_encrypted_value,
        i.is_encrypted_null);
    }
  }

  access::view_traits_impl< ::CoinDB::KeychainView, id_sqlite >::query_base_type
  access::view_traits_impl< ::CoinDB::KeychainView, id_sqlite >::
  query_statement (const query_base_type& q)
  {
    query_base_type r (
      "SELECT "
      "\"Keychain\".\"id\", "
      "\"Keychain\".\"name\", "
      "\"Keychain\".\"depth\", "
      "\"Keychain\".\"parent_fp\", "
      "\"Keychain\".\"child_num\", "
      "\"Keychain\".\"pubkey\", "
      "\"Keychain\".\"hash\", "
      "length(\"Keychain\".\"privkey_ciphertext\") != 0, "
      "\"Keychain\".\"privkey_salt\"!= 0 ");

    r += "FROM \"Keychain\"";

    r += " LEFT JOIN \"Account_keychains\" AS \"t\" ON";
    // From Schema.h:1484:5
    r += "t.value = " + query_columns::Keychain::id;

    r += " LEFT JOIN \"Account\" ON";
    // From Schema.h:1485:5
    r += "t.object_id = " + query_columns::Account::id;

    if (!q.empty ())
    {
      r += " ";
      r += q.clause_prefix ();
      r += q;
    }

    return r;
  }

  result< access::view_traits_impl< ::CoinDB::KeychainView, id_sqlite >::view_type >
  access::view_traits_impl< ::CoinDB::KeychainView, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    const query_base_type& qs (query_statement (q));
    qs.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        qs.clause (),
        false,
        true,
        qs.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::view_result_impl<view_type> > r (
      new (shared) sqlite::view_result_impl<view_type> (
        qs, st, sts, 0));

    return result<view_type> (r);
  }

  // AccountView
  //

  bool access::view_traits_impl< ::CoinDB::AccountView, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = false;

    // name
    //
    if (t[1UL])
    {
      i.name_value.capacity (i.name_size);
      grew = true;
    }

    // minsigs
    //
    t[2UL] = false;

    // unused_pool_size
    //
    t[3UL] = false;

    // time_created
    //
    t[4UL] = false;

    return grew;
  }

  void access::view_traits_impl< ::CoinDB::AccountView, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i)
  {
    using namespace sqlite;

    sqlite::statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    std::size_t n (0);

    // id
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
    n++;

    // name
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.name_value.data ();
    b[n].size = &i.name_size;
    b[n].capacity = i.name_value.capacity ();
    b[n].is_null = &i.name_null;
    n++;

    // minsigs
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.minsigs_value;
    b[n].is_null = &i.minsigs_null;
    n++;

    // unused_pool_size
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.unused_pool_size_value;
    b[n].is_null = &i.unused_pool_size_null;
    n++;

    // time_created
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.time_created_value;
    b[n].is_null = &i.time_created_null;
    n++;
  }

  void access::view_traits_impl< ::CoinDB::AccountView, id_sqlite >::
  init (view_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      long unsigned int& v =
        o.id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // name
    //
    {
      ::std::string& v =
        o.name;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.name_value,
        i.name_size,
        i.name_null);
    }

    // minsigs
    //
    {
      unsigned int& v =
        o.minsigs;

      sqlite::value_traits<
          unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.minsigs_value,
        i.minsigs_null);
    }

    // unused_pool_size
    //
    {
      ::uint32_t& v =
        o.unused_pool_size;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.unused_pool_size_value,
        i.unused_pool_size_null);
    }

    // time_created
    //
    {
      ::uint32_t& v =
        o.time_created;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.time_created_value,
        i.time_created_null);
    }
  }

  access::view_traits_impl< ::CoinDB::AccountView, id_sqlite >::query_base_type
  access::view_traits_impl< ::CoinDB::AccountView, id_sqlite >::
  query_statement (const query_base_type& q)
  {
    query_base_type r (
      "SELECT "
      "\"Account\".\"id\", "
      "\"Account\".\"name\", "
      "\"Account\".\"minsigs\", "
      "\"Account\".\"unused_pool_size\", "
      "\"Account\".\"time_created\" ");

    r += "FROM \"Account\"";

    if (!q.empty ())
    {
      r += " ";
      r += q.clause_prefix ();
      r += q;
    }

    return r;
  }

  result< access::view_traits_impl< ::CoinDB::AccountView, id_sqlite >::view_type >
  access::view_traits_impl< ::CoinDB::AccountView, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    const query_base_type& qs (query_statement (q));
    qs.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        qs.clause (),
        false,
        true,
        qs.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::view_result_impl<view_type> > r (
      new (shared) sqlite::view_result_impl<view_type> (
        qs, st, sts, 0));

    return result<view_type> (r);
  }

  // AccountCountView
  //

  bool access::view_traits_impl< ::CoinDB::AccountCountView, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // count
    //
    t[0UL] = false;

    return grew;
  }

  void access::view_traits_impl< ::CoinDB::AccountCountView, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i)
  {
    using namespace sqlite;

    sqlite::statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    std::size_t n (0);

    // count
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.count_value;
    b[n].is_null = &i.count_null;
    n++;
  }

  void access::view_traits_impl< ::CoinDB::AccountCountView, id_sqlite >::
  init (view_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // count
    //
    {
      ::uint32_t& v =
        o.count;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.count_value,
        i.count_null);
    }
  }

  access::view_traits_impl< ::CoinDB::AccountCountView, id_sqlite >::query_base_type
  access::view_traits_impl< ::CoinDB::AccountCountView, id_sqlite >::
  query_statement (const query_base_type& q)
  {
    query_base_type r (
      "SELECT "
      "count(\"Account\".\"id\") ");

    r += "FROM \"Account\"";

    if (!q.empty ())
    {
      r += " ";
      r += q.clause_prefix ();
      r += q;
    }

    return r;
  }

  result< access::view_traits_impl< ::CoinDB::AccountCountView, id_sqlite >::view_type >
  access::view_traits_impl< ::CoinDB::AccountCountView, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    const query_base_type& qs (query_statement (q));
    qs.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        qs.clause (),
        false,
        true,
        qs.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::view_result_impl<view_type> > r (
      new (shared) sqlite::view_result_impl<view_type> (
        qs, st, sts, 0));

    return result<view_type> (r);
  }

  // AccountBinView
  //

  bool access::view_traits_impl< ::CoinDB::AccountBinView, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // account_id
    //
    t[0UL] = false;

    // account_name
    //
    if (t[1UL])
    {
      i.account_name_value.capacity (i.account_name_size);
      grew = true;
    }

    // account_hash
    //
    if (t[2UL])
    {
      i.account_hash_value.capacity (i.account_hash_size);
      grew = true;
    }

    // bin_id
    //
    t[3UL] = false;

    // bin_name
    //
    if (t[4UL])
    {
      i.bin_name_value.capacity (i.bin_name_size);
      grew = true;
    }

    // bin_hash
    //
    if (t[5UL])
    {
      i.bin_hash_value.capacity (i.bin_hash_size);
      grew = true;
    }

    return grew;
  }

  void access::view_traits_impl< ::CoinDB::AccountBinView, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i)
  {
    using namespace sqlite;

    sqlite::statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    std::size_t n (0);

    // account_id
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.account_id_value;
    b[n].is_null = &i.account_id_null;
    n++;

    // account_name
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.account_name_value.data ();
    b[n].size = &i.account_name_size;
    b[n].capacity = i.account_name_value.capacity ();
    b[n].is_null = &i.account_name_null;
    n++;

    // account_hash
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.account_hash_value.data ();
    b[n].size = &i.account_hash_size;
    b[n].capacity = i.account_hash_value.capacity ();
    b[n].is_null = &i.account_hash_null;
    n++;

    // bin_id
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.bin_id_value;
    b[n].is_null = &i.bin_id_null;
    n++;

    // bin_name
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.bin_name_value.data ();
    b[n].size = &i.bin_name_size;
    b[n].capacity = i.bin_name_value.capacity ();
    b[n].is_null = &i.bin_name_null;
    n++;

    // bin_hash
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.bin_hash_value.data ();
    b[n].size = &i.bin_hash_size;
    b[n].capacity = i.bin_hash_value.capacity ();
    b[n].is_null = &i.bin_hash_null;
    n++;
  }

  void access::view_traits_impl< ::CoinDB::AccountBinView, id_sqlite >::
  init (view_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // account_id
    //
    {
      long unsigned int& v =
        o.account_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.account_id_value,
        i.account_id_null);
    }

    // account_name
    //
    {
      ::std::string& v =
        o.account_name;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.account_name_value,
        i.account_name_size,
        i.account_name_null);
    }

    // account_hash
    //
    {
      ::bytes_t& v =
        o.account_hash;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.account_hash_value,
        i.account_hash_size,
        i.account_hash_null);
    }

    // bin_id
    //
    {
      long unsigned int& v =
        o.bin_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.bin_id_value,
        i.bin_id_null);
    }

    // bin_name
    //
    {
      ::std::string& v =
        o.bin_name;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.bin_name_value,
        i.bin_name_size,
        i.bin_name_null);
    }

    // bin_hash
    //
    {
      ::bytes_t& v =
        o.bin_hash;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.bin_hash_value,
        i.bin_hash_size,
        i.bin_hash_null);
    }
  }

  access::view_traits_impl< ::CoinDB::AccountBinView, id_sqlite >::query_base_type
  access::view_traits_impl< ::CoinDB::AccountBinView, id_sqlite >::
  query_statement (const query_base_type& q)
  {
    query_base_type r (
      "SELECT "
      "\"Account\".\"id\", "
      "\"Account\".\"name\", "
      "\"Account\".\"hash\", "
      "\"AccountBin\".\"id\", "
      "\"AccountBin\".\"name\", "
      "\"AccountBin\".\"hash\" ");

    r += "FROM \"AccountBin\"";

    r += " LEFT JOIN \"Account\" ON";
    r += "\"AccountBin\".\"account\"=\"Account\".\"id\"";

    if (!q.empty ())
    {
      r += " ";
      r += q.clause_prefix ();
      r += q;
    }

    return r;
  }

  result< access::view_traits_impl< ::CoinDB::AccountBinView, id_sqlite >::view_type >
  access::view_traits_impl< ::CoinDB::AccountBinView, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    const query_base_type& qs (query_statement (q));
    qs.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        qs.clause (),
        false,
        true,
        qs.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::view_result_impl<view_type> > r (
      new (shared) sqlite::view_result_impl<view_type> (
        qs, st, sts, 0));

    return result<view_type> (r);
  }

  // SigningScriptView
  //

  bool access::view_traits_impl< ::CoinDB::SigningScriptView, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // account_id
    //
    t[0UL] = false;

    // account_name
    //
    if (t[1UL])
    {
      i.account_name_value.capacity (i.account_name_size);
      grew = true;
    }

    // account_bin_id
    //
    t[2UL] = false;

    // account_bin_name
    //
    if (t[3UL])
    {
      i.account_bin_name_value.capacity (i.account_bin_name_size);
      grew = true;
    }

    // id
    //
    t[4UL] = false;

    // index
    //
    t[5UL] = false;

    // label
    //
    if (t[6UL])
    {
      i.label_value.capacity (i.label_size);
      grew = true;
    }

    // status
    //
    t[7UL] = false;

    // txinscript
    //
    if (t[8UL])
    {
      i.txinscript_value.capacity (i.txinscript_size);
      grew = true;
    }

    // txoutscript
    //
    if (t[9UL])
    {
      i.txoutscript_value.capacity (i.txoutscript_size);
      grew = true;
    }

    return grew;
  }

  void access::view_traits_impl< ::CoinDB::SigningScriptView, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i)
  {
    using namespace sqlite;

    sqlite::statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    std::size_t n (0);

    // account_id
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.account_id_value;
    b[n].is_null = &i.account_id_null;
    n++;

    // account_name
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.account_name_value.data ();
    b[n].size = &i.account_name_size;
    b[n].capacity = i.account_name_value.capacity ();
    b[n].is_null = &i.account_name_null;
    n++;

    // account_bin_id
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.account_bin_id_value;
    b[n].is_null = &i.account_bin_id_null;
    n++;

    // account_bin_name
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.account_bin_name_value.data ();
    b[n].size = &i.account_bin_name_size;
    b[n].capacity = i.account_bin_name_value.capacity ();
    b[n].is_null = &i.account_bin_name_null;
    n++;

    // id
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
    n++;

    // index
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.index_value;
    b[n].is_null = &i.index_null;
    n++;

    // label
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.label_value.data ();
    b[n].size = &i.label_size;
    b[n].capacity = i.label_value.capacity ();
    b[n].is_null = &i.label_null;
    n++;

    // status
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.status_value;
    b[n].is_null = &i.status_null;
    n++;

    // txinscript
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.txinscript_value.data ();
    b[n].size = &i.txinscript_size;
    b[n].capacity = i.txinscript_value.capacity ();
    b[n].is_null = &i.txinscript_null;
    n++;

    // txoutscript
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.txoutscript_value.data ();
    b[n].size = &i.txoutscript_size;
    b[n].capacity = i.txoutscript_value.capacity ();
    b[n].is_null = &i.txoutscript_null;
    n++;
  }

  void access::view_traits_impl< ::CoinDB::SigningScriptView, id_sqlite >::
  init (view_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // account_id
    //
    {
      long unsigned int& v =
        o.account_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.account_id_value,
        i.account_id_null);
    }

    // account_name
    //
    {
      ::std::string& v =
        o.account_name;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.account_name_value,
        i.account_name_size,
        i.account_name_null);
    }

    // account_bin_id
    //
    {
      long unsigned int& v =
        o.account_bin_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.account_bin_id_value,
        i.account_bin_id_null);
    }

    // account_bin_name
    //
    {
      ::std::string& v =
        o.account_bin_name;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.account_bin_name_value,
        i.account_bin_name_size,
        i.account_bin_name_null);
    }

    // id
    //
    {
      long unsigned int& v =
        o.id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // index
    //
    {
      ::uint32_t& v =
        o.index;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.index_value,
        i.index_null);
    }

    // label
    //
    {
      ::std::string& v =
        o.label;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.label_value,
        i.label_size,
        i.label_null);
    }

    // status
    //
    {
      ::CoinDB::SigningScript::status_t& v =
        o.status;

      sqlite::value_traits<
          ::CoinDB::SigningScript::status_t,
          sqlite::id_integer >::set_value (
        v,
        i.status_value,
        i.status_null);
    }

    // txinscript
    //
    {
      ::bytes_t& v =
        o.txinscript;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.txinscript_value,
        i.txinscript_size,
        i.txinscript_null);
    }

    // txoutscript
    //
    {
      ::bytes_t& v =
        o.txoutscript;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.txoutscript_value,
        i.txoutscript_size,
        i.txoutscript_null);
    }
  }

  access::view_traits_impl< ::CoinDB::SigningScriptView, id_sqlite >::query_base_type
  access::view_traits_impl< ::CoinDB::SigningScriptView, id_sqlite >::
  query_statement (const query_base_type& q)
  {
    query_base_type r (
      "SELECT "
      "\"Account\".\"id\", "
      "\"Account\".\"name\", "
      "\"AccountBin\".\"id\", "
      "\"AccountBin\".\"name\", "
      "\"SigningScript\".\"id\", "
      "\"SigningScript\".\"index\", "
      "\"SigningScript\".\"label\", "
      "\"SigningScript\".\"status\", "
      "\"SigningScript\".\"txinscript\", "
      "\"SigningScript\".\"txoutscript\" ");

    r += "FROM \"SigningScript\"";

    r += " LEFT JOIN \"Account\" ON";
    r += "\"SigningScript\".\"account\"=\"Account\".\"id\"";

    r += " LEFT JOIN \"AccountBin\" ON";
    r += "\"SigningScript\".\"account_bin\"=\"AccountBin\".\"id\"";

    if (!q.empty ())
    {
      r += " ";
      r += q.clause_prefix ();
      r += q;
    }

    return r;
  }

  result< access::view_traits_impl< ::CoinDB::SigningScriptView, id_sqlite >::view_type >
  access::view_traits_impl< ::CoinDB::SigningScriptView, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    const query_base_type& qs (query_statement (q));
    qs.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        qs.clause (),
        false,
        true,
        qs.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::view_result_impl<view_type> > r (
      new (shared) sqlite::view_result_impl<view_type> (
        qs, st, sts, 0));

    return result<view_type> (r);
  }

  // ScriptCountView
  //

  bool access::view_traits_impl< ::CoinDB::ScriptCountView, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // count
    //
    t[0UL] = false;

    // max_index
    //
    t[1UL] = false;

    return grew;
  }

  void access::view_traits_impl< ::CoinDB::ScriptCountView, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i)
  {
    using namespace sqlite;

    sqlite::statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    std::size_t n (0);

    // count
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.count_value;
    b[n].is_null = &i.count_null;
    n++;

    // max_index
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.max_index_value;
    b[n].is_null = &i.max_index_null;
    n++;
  }

  void access::view_traits_impl< ::CoinDB::ScriptCountView, id_sqlite >::
  init (view_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // count
    //
    {
      ::uint32_t& v =
        o.count;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.count_value,
        i.count_null);
    }

    // max_index
    //
    {
      long unsigned int& v =
        o.max_index;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.max_index_value,
        i.max_index_null);
    }
  }

  access::view_traits_impl< ::CoinDB::ScriptCountView, id_sqlite >::query_base_type
  access::view_traits_impl< ::CoinDB::ScriptCountView, id_sqlite >::
  query_statement (const query_base_type& q)
  {
    query_base_type r (
      "SELECT "
      "count(\"SigningScript\".\"id\"), "
      "max(\"SigningScript\".\"index\") ");

    r += "FROM \"SigningScript\"";

    r += " LEFT JOIN \"Account\" ON";
    r += "\"SigningScript\".\"account\"=\"Account\".\"id\"";

    r += " LEFT JOIN \"AccountBin\" ON";
    r += "\"SigningScript\".\"account_bin\"=\"AccountBin\".\"id\"";

    if (!q.empty ())
    {
      r += " ";
      r += q.clause_prefix ();
      r += q;
    }

    return r;
  }

  result< access::view_traits_impl< ::CoinDB::ScriptCountView, id_sqlite >::view_type >
  access::view_traits_impl< ::CoinDB::ScriptCountView, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    const query_base_type& qs (query_statement (q));
    qs.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        qs.clause (),
        false,
        true,
        qs.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::view_result_impl<view_type> > r (
      new (shared) sqlite::view_result_impl<view_type> (
        qs, st, sts, 0));

    return result<view_type> (r);
  }

  // TxView
  //

  bool access::view_traits_impl< ::CoinDB::TxView, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // id
    //
    t[0UL] = false;

    // hash
    //
    if (t[1UL])
    {
      i.hash_value.capacity (i.hash_size);
      grew = true;
    }

    // unsigned_hash
    //
    if (t[2UL])
    {
      i.unsigned_hash_value.capacity (i.unsigned_hash_size);
      grew = true;
    }

    // version
    //
    t[3UL] = false;

    // locktime
    //
    t[4UL] = false;

    // timestamp
    //
    t[5UL] = false;

    // status
    //
    t[6UL] = false;

    // have_all_outpoints
    //
    t[7UL] = false;

    // txin_total
    //
    t[8UL] = false;

    // txout_total
    //
    t[9UL] = false;

    // height
    //
    t[10UL] = false;

    return grew;
  }

  void access::view_traits_impl< ::CoinDB::TxView, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i)
  {
    using namespace sqlite;

    sqlite::statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    std::size_t n (0);

    // id
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
    n++;

    // hash
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.hash_value.data ();
    b[n].size = &i.hash_size;
    b[n].capacity = i.hash_value.capacity ();
    b[n].is_null = &i.hash_null;
    n++;

    // unsigned_hash
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.unsigned_hash_value.data ();
    b[n].size = &i.unsigned_hash_size;
    b[n].capacity = i.unsigned_hash_value.capacity ();
    b[n].is_null = &i.unsigned_hash_null;
    n++;

    // version
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.version_value;
    b[n].is_null = &i.version_null;
    n++;

    // locktime
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.locktime_value;
    b[n].is_null = &i.locktime_null;
    n++;

    // timestamp
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.timestamp_value;
    b[n].is_null = &i.timestamp_null;
    n++;

    // status
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.status_value;
    b[n].is_null = &i.status_null;
    n++;

    // have_all_outpoints
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.have_all_outpoints_value;
    b[n].is_null = &i.have_all_outpoints_null;
    n++;

    // txin_total
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.txin_total_value;
    b[n].is_null = &i.txin_total_null;
    n++;

    // txout_total
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.txout_total_value;
    b[n].is_null = &i.txout_total_null;
    n++;

    // height
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.height_value;
    b[n].is_null = &i.height_null;
    n++;
  }

  void access::view_traits_impl< ::CoinDB::TxView, id_sqlite >::
  init (view_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // id
    //
    {
      long unsigned int& v =
        o.id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // hash
    //
    {
      ::bytes_t& v =
        o.hash;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.hash_value,
        i.hash_size,
        i.hash_null);
    }

    // unsigned_hash
    //
    {
      ::bytes_t& v =
        o.unsigned_hash;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.unsigned_hash_value,
        i.unsigned_hash_size,
        i.unsigned_hash_null);
    }

    // version
    //
    {
      ::uint32_t& v =
        o.version;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.version_value,
        i.version_null);
    }

    // locktime
    //
    {
      ::uint32_t& v =
        o.locktime;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.locktime_value,
        i.locktime_null);
    }

    // timestamp
    //
    {
      ::uint32_t& v =
        o.timestamp;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.timestamp_value,
        i.timestamp_null);
    }

    // status
    //
    {
      ::CoinDB::Tx::status_t& v =
        o.status;

      sqlite::value_traits<
          ::CoinDB::Tx::status_t,
          sqlite::id_integer >::set_value (
        v,
        i.status_value,
        i.status_null);
    }

    // have_all_outpoints
    //
    {
      bool& v =
        o.have_all_outpoints;

      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_value (
        v,
        i.have_all_outpoints_value,
        i.have_all_outpoints_null);
    }

    // txin_total
    //
    {
      ::uint64_t& v =
        o.txin_total;

      sqlite::value_traits<
          ::uint64_t,
          sqlite::id_integer >::set_value (
        v,
        i.txin_total_value,
        i.txin_total_null);
    }

    // txout_total
    //
    {
      ::uint64_t& v =
        o.txout_total;

      sqlite::value_traits<
          ::uint64_t,
          sqlite::id_integer >::set_value (
        v,
        i.txout_total_value,
        i.txout_total_null);
    }

    // height
    //
    {
      ::uint32_t& v =
        o.height;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.height_value,
        i.height_null);
    }
  }

  access::view_traits_impl< ::CoinDB::TxView, id_sqlite >::query_base_type
  access::view_traits_impl< ::CoinDB::TxView, id_sqlite >::
  query_statement (const query_base_type& q)
  {
    query_base_type r (
      "SELECT "
      "\"Tx\".\"id\", "
      "\"Tx\".\"hash\", "
      "\"Tx\".\"unsigned_hash\", "
      "\"Tx\".\"version\", "
      "\"Tx\".\"locktime\", "
      "\"Tx\".\"timestamp\", "
      "\"Tx\".\"status\", "
      "\"Tx\".\"have_all_outpoints\", "
      "\"Tx\".\"txin_total\", "
      "\"Tx\".\"txout_total\", "
      "\"BlockHeader\".\"height\" ");

    r += "FROM \"Tx\"";

    r += " LEFT JOIN \"BlockHeader\" ON";
    r += "\"Tx\".\"blockheader\"=\"BlockHeader\".\"id\"";

    if (!q.empty ())
    {
      r += " ";
      r += q.clause_prefix ();
      r += q;
    }

    return r;
  }

  result< access::view_traits_impl< ::CoinDB::TxView, id_sqlite >::view_type >
  access::view_traits_impl< ::CoinDB::TxView, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    const query_base_type& qs (query_statement (q));
    qs.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        qs.clause (),
        false,
        true,
        qs.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::view_result_impl<view_type> > r (
      new (shared) sqlite::view_result_impl<view_type> (
        qs, st, sts, 0));

    return result<view_type> (r);
  }

  // TxOutView
  //

  const char alias_traits<  ::CoinDB::Account,
    id_sqlite,
    access::view_traits_impl< ::CoinDB::TxOutView, id_sqlite >::sending_account_tag>::
  table_name[] = "\"sending_account\"";

  const char alias_traits<  ::CoinDB::Account,
    id_sqlite,
    access::view_traits_impl< ::CoinDB::TxOutView, id_sqlite >::receiving_account_tag>::
  table_name[] = "\"receiving_account\"";

  bool access::view_traits_impl< ::CoinDB::TxOutView, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // sending_account_id
    //
    t[0UL] = false;

    // sending_account_name
    //
    if (t[1UL])
    {
      i.sending_account_name_value.capacity (i.sending_account_name_size);
      grew = true;
    }

    // receiving_account_id
    //
    t[2UL] = false;

    // receiving_account_name
    //
    if (t[3UL])
    {
      i.receiving_account_name_value.capacity (i.receiving_account_name_size);
      grew = true;
    }

    // account_bin_id
    //
    t[4UL] = false;

    // account_bin_name
    //
    if (t[5UL])
    {
      i.account_bin_name_value.capacity (i.account_bin_name_size);
      grew = true;
    }

    // signingscript_id
    //
    t[6UL] = false;

    // signingscript_label
    //
    if (t[7UL])
    {
      i.signingscript_label_value.capacity (i.signingscript_label_size);
      grew = true;
    }

    // signingscript_status
    //
    t[8UL] = false;

    // signingscript_txinscript
    //
    if (t[9UL])
    {
      i.signingscript_txinscript_value.capacity (i.signingscript_txinscript_size);
      grew = true;
    }

    // id
    //
    t[10UL] = false;

    // script
    //
    if (t[11UL])
    {
      i.script_value.capacity (i.script_size);
      grew = true;
    }

    // value
    //
    t[12UL] = false;

    // status
    //
    t[13UL] = false;

    // sending_label
    //
    if (t[14UL])
    {
      i.sending_label_value.capacity (i.sending_label_size);
      grew = true;
    }

    // receiving_label
    //
    if (t[15UL])
    {
      i.receiving_label_value.capacity (i.receiving_label_size);
      grew = true;
    }

    // tx_id
    //
    t[16UL] = false;

    // tx_unsigned_hash
    //
    if (t[17UL])
    {
      i.tx_unsigned_hash_value.capacity (i.tx_unsigned_hash_size);
      grew = true;
    }

    // tx_hash
    //
    if (t[18UL])
    {
      i.tx_hash_value.capacity (i.tx_hash_size);
      grew = true;
    }

    // tx_timestamp
    //
    t[19UL] = false;

    // tx_status
    //
    t[20UL] = false;

    // tx_has_all_outpoints
    //
    t[21UL] = false;

    // tx_txin_total
    //
    t[22UL] = false;

    // tx_txout_total
    //
    t[23UL] = false;

    // tx_index
    //
    t[24UL] = false;

    // height
    //
    t[25UL] = false;

    return grew;
  }

  void access::view_traits_impl< ::CoinDB::TxOutView, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i)
  {
    using namespace sqlite;

    sqlite::statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    std::size_t n (0);

    // sending_account_id
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.sending_account_id_value;
    b[n].is_null = &i.sending_account_id_null;
    n++;

    // sending_account_name
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.sending_account_name_value.data ();
    b[n].size = &i.sending_account_name_size;
    b[n].capacity = i.sending_account_name_value.capacity ();
    b[n].is_null = &i.sending_account_name_null;
    n++;

    // receiving_account_id
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.receiving_account_id_value;
    b[n].is_null = &i.receiving_account_id_null;
    n++;

    // receiving_account_name
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.receiving_account_name_value.data ();
    b[n].size = &i.receiving_account_name_size;
    b[n].capacity = i.receiving_account_name_value.capacity ();
    b[n].is_null = &i.receiving_account_name_null;
    n++;

    // account_bin_id
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.account_bin_id_value;
    b[n].is_null = &i.account_bin_id_null;
    n++;

    // account_bin_name
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.account_bin_name_value.data ();
    b[n].size = &i.account_bin_name_size;
    b[n].capacity = i.account_bin_name_value.capacity ();
    b[n].is_null = &i.account_bin_name_null;
    n++;

    // signingscript_id
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.signingscript_id_value;
    b[n].is_null = &i.signingscript_id_null;
    n++;

    // signingscript_label
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.signingscript_label_value.data ();
    b[n].size = &i.signingscript_label_size;
    b[n].capacity = i.signingscript_label_value.capacity ();
    b[n].is_null = &i.signingscript_label_null;
    n++;

    // signingscript_status
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.signingscript_status_value;
    b[n].is_null = &i.signingscript_status_null;
    n++;

    // signingscript_txinscript
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.signingscript_txinscript_value.data ();
    b[n].size = &i.signingscript_txinscript_size;
    b[n].capacity = i.signingscript_txinscript_value.capacity ();
    b[n].is_null = &i.signingscript_txinscript_null;
    n++;

    // id
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.id_value;
    b[n].is_null = &i.id_null;
    n++;

    // script
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.script_value.data ();
    b[n].size = &i.script_size;
    b[n].capacity = i.script_value.capacity ();
    b[n].is_null = &i.script_null;
    n++;

    // value
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.value_value;
    b[n].is_null = &i.value_null;
    n++;

    // status
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.status_value;
    b[n].is_null = &i.status_null;
    n++;

    // sending_label
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.sending_label_value.data ();
    b[n].size = &i.sending_label_size;
    b[n].capacity = i.sending_label_value.capacity ();
    b[n].is_null = &i.sending_label_null;
    n++;

    // receiving_label
    //
    b[n].type = sqlite::image_traits<
      ::std::string,
      sqlite::id_text>::bind_value;
    b[n].buffer = i.receiving_label_value.data ();
    b[n].size = &i.receiving_label_size;
    b[n].capacity = i.receiving_label_value.capacity ();
    b[n].is_null = &i.receiving_label_null;
    n++;

    // tx_id
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.tx_id_value;
    b[n].is_null = &i.tx_id_null;
    n++;

    // tx_unsigned_hash
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.tx_unsigned_hash_value.data ();
    b[n].size = &i.tx_unsigned_hash_size;
    b[n].capacity = i.tx_unsigned_hash_value.capacity ();
    b[n].is_null = &i.tx_unsigned_hash_null;
    n++;

    // tx_hash
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.tx_hash_value.data ();
    b[n].size = &i.tx_hash_size;
    b[n].capacity = i.tx_hash_value.capacity ();
    b[n].is_null = &i.tx_hash_null;
    n++;

    // tx_timestamp
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.tx_timestamp_value;
    b[n].is_null = &i.tx_timestamp_null;
    n++;

    // tx_status
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.tx_status_value;
    b[n].is_null = &i.tx_status_null;
    n++;

    // tx_has_all_outpoints
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.tx_has_all_outpoints_value;
    b[n].is_null = &i.tx_has_all_outpoints_null;
    n++;

    // tx_txin_total
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.tx_txin_total_value;
    b[n].is_null = &i.tx_txin_total_null;
    n++;

    // tx_txout_total
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.tx_txout_total_value;
    b[n].is_null = &i.tx_txout_total_null;
    n++;

    // tx_index
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.tx_index_value;
    b[n].is_null = &i.tx_index_null;
    n++;

    // height
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.height_value;
    b[n].is_null = &i.height_null;
    n++;
  }

  void access::view_traits_impl< ::CoinDB::TxOutView, id_sqlite >::
  init (view_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // sending_account_id
    //
    {
      long unsigned int& v =
        o.sending_account_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.sending_account_id_value,
        i.sending_account_id_null);
    }

    // sending_account_name
    //
    {
      ::std::string& v =
        o.sending_account_name;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.sending_account_name_value,
        i.sending_account_name_size,
        i.sending_account_name_null);
    }

    // receiving_account_id
    //
    {
      long unsigned int& v =
        o.receiving_account_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.receiving_account_id_value,
        i.receiving_account_id_null);
    }

    // receiving_account_name
    //
    {
      ::std::string& v =
        o.receiving_account_name;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.receiving_account_name_value,
        i.receiving_account_name_size,
        i.receiving_account_name_null);
    }

    // account_bin_id
    //
    {
      long unsigned int& v =
        o.account_bin_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.account_bin_id_value,
        i.account_bin_id_null);
    }

    // account_bin_name
    //
    {
      ::std::string& v =
        o.account_bin_name;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.account_bin_name_value,
        i.account_bin_name_size,
        i.account_bin_name_null);
    }

    // signingscript_id
    //
    {
      long unsigned int& v =
        o.signingscript_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.signingscript_id_value,
        i.signingscript_id_null);
    }

    // signingscript_label
    //
    {
      ::std::string& v =
        o.signingscript_label;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.signingscript_label_value,
        i.signingscript_label_size,
        i.signingscript_label_null);
    }

    // signingscript_status
    //
    {
      ::CoinDB::SigningScript::status_t& v =
        o.signingscript_status;

      sqlite::value_traits<
          ::CoinDB::SigningScript::status_t,
          sqlite::id_integer >::set_value (
        v,
        i.signingscript_status_value,
        i.signingscript_status_null);
    }

    // signingscript_txinscript
    //
    {
      ::bytes_t& v =
        o.signingscript_txinscript;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.signingscript_txinscript_value,
        i.signingscript_txinscript_size,
        i.signingscript_txinscript_null);
    }

    // id
    //
    {
      long unsigned int& v =
        o.id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.id_value,
        i.id_null);
    }

    // script
    //
    {
      ::bytes_t& v =
        o.script;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.script_value,
        i.script_size,
        i.script_null);
    }

    // value
    //
    {
      ::uint64_t& v =
        o.value;

      sqlite::value_traits<
          ::uint64_t,
          sqlite::id_integer >::set_value (
        v,
        i.value_value,
        i.value_null);
    }

    // status
    //
    {
      ::CoinDB::TxOut::status_t& v =
        o.status;

      sqlite::value_traits<
          ::CoinDB::TxOut::status_t,
          sqlite::id_integer >::set_value (
        v,
        i.status_value,
        i.status_null);
    }

    // sending_label
    //
    {
      ::std::string& v =
        o.sending_label;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.sending_label_value,
        i.sending_label_size,
        i.sending_label_null);
    }

    // receiving_label
    //
    {
      ::std::string& v =
        o.receiving_label;

      sqlite::value_traits<
          ::std::string,
          sqlite::id_text >::set_value (
        v,
        i.receiving_label_value,
        i.receiving_label_size,
        i.receiving_label_null);
    }

    // tx_id
    //
    {
      long unsigned int& v =
        o.tx_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.tx_id_value,
        i.tx_id_null);
    }

    // tx_unsigned_hash
    //
    {
      ::bytes_t& v =
        o.tx_unsigned_hash;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.tx_unsigned_hash_value,
        i.tx_unsigned_hash_size,
        i.tx_unsigned_hash_null);
    }

    // tx_hash
    //
    {
      ::bytes_t& v =
        o.tx_hash;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.tx_hash_value,
        i.tx_hash_size,
        i.tx_hash_null);
    }

    // tx_timestamp
    //
    {
      ::uint32_t& v =
        o.tx_timestamp;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.tx_timestamp_value,
        i.tx_timestamp_null);
    }

    // tx_status
    //
    {
      ::CoinDB::Tx::status_t& v =
        o.tx_status;

      sqlite::value_traits<
          ::CoinDB::Tx::status_t,
          sqlite::id_integer >::set_value (
        v,
        i.tx_status_value,
        i.tx_status_null);
    }

    // tx_has_all_outpoints
    //
    {
      bool& v =
        o.tx_has_all_outpoints;

      sqlite::value_traits<
          bool,
          sqlite::id_integer >::set_value (
        v,
        i.tx_has_all_outpoints_value,
        i.tx_has_all_outpoints_null);
    }

    // tx_txin_total
    //
    {
      ::uint64_t& v =
        o.tx_txin_total;

      sqlite::value_traits<
          ::uint64_t,
          sqlite::id_integer >::set_value (
        v,
        i.tx_txin_total_value,
        i.tx_txin_total_null);
    }

    // tx_txout_total
    //
    {
      ::uint64_t& v =
        o.tx_txout_total;

      sqlite::value_traits<
          ::uint64_t,
          sqlite::id_integer >::set_value (
        v,
        i.tx_txout_total_value,
        i.tx_txout_total_null);
    }

    // tx_index
    //
    {
      ::uint32_t& v =
        o.tx_index;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.tx_index_value,
        i.tx_index_null);
    }

    // height
    //
    {
      ::uint32_t& v =
        o.height;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.height_value,
        i.height_null);
    }
  }

  access::view_traits_impl< ::CoinDB::TxOutView, id_sqlite >::query_base_type
  access::view_traits_impl< ::CoinDB::TxOutView, id_sqlite >::
  query_statement (const query_base_type& q)
  {
    query_base_type r (
      "SELECT "
      "\"sending_account\".\"id\", "
      "\"sending_account\".\"name\", "
      "\"receiving_account\".\"id\", "
      "\"receiving_account\".\"name\", "
      "\"AccountBin\".\"id\", "
      "\"AccountBin\".\"name\", "
      "\"SigningScript\".\"id\", "
      "\"SigningScript\".\"label\", "
      "\"SigningScript\".\"status\", "
      "\"SigningScript\".\"txinscript\", "
      "\"TxOut\".\"id\", "
      "\"TxOut\".\"script\", "
      "\"TxOut\".\"value\", "
      "\"TxOut\".\"status\", "
      "\"TxOut\".\"sending_label\", "
      "\"TxOut\".\"receiving_label\", "
      "\"Tx\".\"id\", "
      "\"Tx\".\"unsigned_hash\", "
      "\"Tx\".\"hash\", "
      "\"Tx\".\"timestamp\", "
      "\"Tx\".\"status\", "
      "\"Tx\".\"have_all_outpoints\", "
      "\"Tx\".\"txin_total\", "
      "\"Tx\".\"txout_total\", "
      "\"TxOut\".\"txindex\", "
      "\"BlockHeader\".\"height\" ");

    r += "FROM \"TxOut\"";

    r += " LEFT JOIN \"Tx\" ON";
    r += "\"TxOut\".\"tx\"=\"Tx\".\"id\"";

    r += " LEFT JOIN \"BlockHeader\" ON";
    r += "\"Tx\".\"blockheader\"=\"BlockHeader\".\"id\"";

    r += " LEFT JOIN \"Account\" AS \"sending_account\" ON";
    r += "\"TxOut\".\"sending_account\"=\"sending_account\".\"id\"";

    r += " LEFT JOIN \"Account\" AS \"receiving_account\" ON";
    r += "\"TxOut\".\"receiving_account\"=\"receiving_account\".\"id\"";

    r += " LEFT JOIN \"AccountBin\" ON";
    r += "\"TxOut\".\"account_bin\"=\"AccountBin\".\"id\"";

    r += " LEFT JOIN \"SigningScript\" ON";
    r += "\"TxOut\".\"signingscript\"=\"SigningScript\".\"id\"";

    if (!q.empty ())
    {
      r += " ";
      r += q.clause_prefix ();
      r += q;
    }

    return r;
  }

  result< access::view_traits_impl< ::CoinDB::TxOutView, id_sqlite >::view_type >
  access::view_traits_impl< ::CoinDB::TxOutView, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    const query_base_type& qs (query_statement (q));
    qs.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        qs.clause (),
        false,
        true,
        qs.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::view_result_impl<view_type> > r (
      new (shared) sqlite::view_result_impl<view_type> (
        qs, st, sts, 0));

    return result<view_type> (r);
  }

  // BalanceView
  //

  bool access::view_traits_impl< ::CoinDB::BalanceView, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // balance
    //
    t[0UL] = false;

    return grew;
  }

  void access::view_traits_impl< ::CoinDB::BalanceView, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i)
  {
    using namespace sqlite;

    sqlite::statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    std::size_t n (0);

    // balance
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.balance_value;
    b[n].is_null = &i.balance_null;
    n++;
  }

  void access::view_traits_impl< ::CoinDB::BalanceView, id_sqlite >::
  init (view_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // balance
    //
    {
      ::uint64_t& v =
        o.balance;

      sqlite::value_traits<
          ::uint64_t,
          sqlite::id_integer >::set_value (
        v,
        i.balance_value,
        i.balance_null);
    }
  }

  access::view_traits_impl< ::CoinDB::BalanceView, id_sqlite >::query_base_type
  access::view_traits_impl< ::CoinDB::BalanceView, id_sqlite >::
  query_statement (const query_base_type& q)
  {
    query_base_type r (
      "SELECT "
      "sum(\"TxOut\".\"value\") ");

    r += "FROM \"TxOut\"";

    r += " LEFT JOIN \"Tx\" ON";
    r += "\"TxOut\".\"tx\"=\"Tx\".\"id\"";

    r += " LEFT JOIN \"BlockHeader\" ON";
    r += "\"Tx\".\"blockheader\"=\"BlockHeader\".\"id\"";

    r += " LEFT JOIN \"Account\" ON";
    r += "\"TxOut\".\"receiving_account\"=\"Account\".\"id\"";

    r += " LEFT JOIN \"AccountBin\" ON";
    r += "\"TxOut\".\"account_bin\"=\"AccountBin\".\"id\"";

    r += " LEFT JOIN \"SigningScript\" ON";
    r += "\"TxOut\".\"signingscript\"=\"SigningScript\".\"id\"";

    if (!q.empty ())
    {
      r += " ";
      r += q.clause_prefix ();
      r += q;
    }

    return r;
  }

  result< access::view_traits_impl< ::CoinDB::BalanceView, id_sqlite >::view_type >
  access::view_traits_impl< ::CoinDB::BalanceView, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    const query_base_type& qs (query_statement (q));
    qs.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        qs.clause (),
        false,
        true,
        qs.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::view_result_impl<view_type> > r (
      new (shared) sqlite::view_result_impl<view_type> (
        qs, st, sts, 0));

    return result<view_type> (r);
  }

  // BestHeightView
  //

  bool access::view_traits_impl< ::CoinDB::BestHeightView, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // height
    //
    t[0UL] = false;

    return grew;
  }

  void access::view_traits_impl< ::CoinDB::BestHeightView, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i)
  {
    using namespace sqlite;

    sqlite::statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    std::size_t n (0);

    // height
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.height_value;
    b[n].is_null = &i.height_null;
    n++;
  }

  void access::view_traits_impl< ::CoinDB::BestHeightView, id_sqlite >::
  init (view_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // height
    //
    {
      ::uint32_t& v =
        o.height;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.height_value,
        i.height_null);
    }
  }

  access::view_traits_impl< ::CoinDB::BestHeightView, id_sqlite >::query_base_type
  access::view_traits_impl< ::CoinDB::BestHeightView, id_sqlite >::
  query_statement (const query_base_type& q)
  {
    query_base_type r (
      "SELECT "
      "max(\"BlockHeader\".\"height\") ");

    r += "FROM \"MerkleBlock\"";

    r += " LEFT JOIN \"BlockHeader\" ON";
    r += "\"MerkleBlock\".\"blockheader\"=\"BlockHeader\".\"id\"";

    query_base_type c (
      // From Schema.h:1840:2
      query_columns::MerkleBlock::txsinserted == true);

    c += q;

    if (!c.empty ())
    {
      r += " ";
      r += c.clause_prefix ();
      r += c;
    }

    return r;
  }

  result< access::view_traits_impl< ::CoinDB::BestHeightView, id_sqlite >::view_type >
  access::view_traits_impl< ::CoinDB::BestHeightView, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    const query_base_type& qs (query_statement (q));
    qs.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        qs.clause (),
        false,
        true,
        qs.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::view_result_impl<view_type> > r (
      new (shared) sqlite::view_result_impl<view_type> (
        qs, st, sts, 0));

    return result<view_type> (r);
  }

  // HorizonHeightView
  //

  bool access::view_traits_impl< ::CoinDB::HorizonHeightView, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // height
    //
    t[0UL] = false;

    return grew;
  }

  void access::view_traits_impl< ::CoinDB::HorizonHeightView, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i)
  {
    using namespace sqlite;

    sqlite::statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    std::size_t n (0);

    // height
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.height_value;
    b[n].is_null = &i.height_null;
    n++;
  }

  void access::view_traits_impl< ::CoinDB::HorizonHeightView, id_sqlite >::
  init (view_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // height
    //
    {
      ::uint32_t& v =
        o.height;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.height_value,
        i.height_null);
    }
  }

  access::view_traits_impl< ::CoinDB::HorizonHeightView, id_sqlite >::query_base_type
  access::view_traits_impl< ::CoinDB::HorizonHeightView, id_sqlite >::
  query_statement (const query_base_type& q)
  {
    query_base_type r (
      "SELECT "
      "min(\"BlockHeader\".\"height\") ");

    r += "FROM \"BlockHeader\"";

    if (!q.empty ())
    {
      r += " ";
      r += q.clause_prefix ();
      r += q;
    }

    return r;
  }

  result< access::view_traits_impl< ::CoinDB::HorizonHeightView, id_sqlite >::view_type >
  access::view_traits_impl< ::CoinDB::HorizonHeightView, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    const query_base_type& qs (query_statement (q));
    qs.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        qs.clause (),
        false,
        true,
        qs.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::view_result_impl<view_type> > r (
      new (shared) sqlite::view_result_impl<view_type> (
        qs, st, sts, 0));

    return result<view_type> (r);
  }

  // BlockCountView
  //

  bool access::view_traits_impl< ::CoinDB::BlockCountView, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // count
    //
    t[0UL] = false;

    return grew;
  }

  void access::view_traits_impl< ::CoinDB::BlockCountView, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i)
  {
    using namespace sqlite;

    sqlite::statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    std::size_t n (0);

    // count
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.count_value;
    b[n].is_null = &i.count_null;
    n++;
  }

  void access::view_traits_impl< ::CoinDB::BlockCountView, id_sqlite >::
  init (view_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // count
    //
    {
      long unsigned int& v =
        o.count;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.count_value,
        i.count_null);
    }
  }

  access::view_traits_impl< ::CoinDB::BlockCountView, id_sqlite >::query_base_type
  access::view_traits_impl< ::CoinDB::BlockCountView, id_sqlite >::
  query_statement (const query_base_type& q)
  {
    query_base_type r (
      "SELECT "
      "count(\"BlockHeader\".\"id\") ");

    r += "FROM \"BlockHeader\"";

    if (!q.empty ())
    {
      r += " ";
      r += q.clause_prefix ();
      r += q;
    }

    return r;
  }

  result< access::view_traits_impl< ::CoinDB::BlockCountView, id_sqlite >::view_type >
  access::view_traits_impl< ::CoinDB::BlockCountView, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    const query_base_type& qs (query_statement (q));
    qs.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        qs.clause (),
        false,
        true,
        qs.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::view_result_impl<view_type> > r (
      new (shared) sqlite::view_result_impl<view_type> (
        qs, st, sts, 0));

    return result<view_type> (r);
  }

  // MerkleBlockCountView
  //

  bool access::view_traits_impl< ::CoinDB::MerkleBlockCountView, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // count
    //
    t[0UL] = false;

    return grew;
  }

  void access::view_traits_impl< ::CoinDB::MerkleBlockCountView, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i)
  {
    using namespace sqlite;

    sqlite::statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    std::size_t n (0);

    // count
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.count_value;
    b[n].is_null = &i.count_null;
    n++;
  }

  void access::view_traits_impl< ::CoinDB::MerkleBlockCountView, id_sqlite >::
  init (view_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // count
    //
    {
      long unsigned int& v =
        o.count;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.count_value,
        i.count_null);
    }
  }

  access::view_traits_impl< ::CoinDB::MerkleBlockCountView, id_sqlite >::query_base_type
  access::view_traits_impl< ::CoinDB::MerkleBlockCountView, id_sqlite >::
  query_statement (const query_base_type& q)
  {
    query_base_type r (
      "SELECT "
      "count(\"MerkleBlock\".\"id\") ");

    r += "FROM \"MerkleBlock\"";

    if (!q.empty ())
    {
      r += " ";
      r += q.clause_prefix ();
      r += q;
    }

    return r;
  }

  result< access::view_traits_impl< ::CoinDB::MerkleBlockCountView, id_sqlite >::view_type >
  access::view_traits_impl< ::CoinDB::MerkleBlockCountView, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    const query_base_type& qs (query_statement (q));
    qs.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        qs.clause (),
        false,
        true,
        qs.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::view_result_impl<view_type> > r (
      new (shared) sqlite::view_result_impl<view_type> (
        qs, st, sts, 0));

    return result<view_type> (r);
  }

  // HorizonTimestampView
  //

  bool access::view_traits_impl< ::CoinDB::HorizonTimestampView, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // timestamp
    //
    t[0UL] = false;

    return grew;
  }

  void access::view_traits_impl< ::CoinDB::HorizonTimestampView, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i)
  {
    using namespace sqlite;

    sqlite::statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    std::size_t n (0);

    // timestamp
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.timestamp_value;
    b[n].is_null = &i.timestamp_null;
    n++;
  }

  void access::view_traits_impl< ::CoinDB::HorizonTimestampView, id_sqlite >::
  init (view_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // timestamp
    //
    {
      ::uint32_t& v =
        o.timestamp;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.timestamp_value,
        i.timestamp_null);
    }
  }

  access::view_traits_impl< ::CoinDB::HorizonTimestampView, id_sqlite >::query_base_type
  access::view_traits_impl< ::CoinDB::HorizonTimestampView, id_sqlite >::
  query_statement (const query_base_type& q)
  {
    query_base_type r (
      "SELECT "
      "min(\"Account\".\"time_created\") ");

    r += "FROM \"Account\"";

    if (!q.empty ())
    {
      r += " ";
      r += q.clause_prefix ();
      r += q;
    }

    return r;
  }

  result< access::view_traits_impl< ::CoinDB::HorizonTimestampView, id_sqlite >::view_type >
  access::view_traits_impl< ::CoinDB::HorizonTimestampView, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    const query_base_type& qs (query_statement (q));
    qs.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        qs.clause (),
        false,
        true,
        qs.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::view_result_impl<view_type> > r (
      new (shared) sqlite::view_result_impl<view_type> (
        qs, st, sts, 0));

    return result<view_type> (r);
  }

  // ConfirmedTxView
  //

  bool access::view_traits_impl< ::CoinDB::ConfirmedTxView, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // tx_id
    //
    t[0UL] = false;

    // tx_hash
    //
    if (t[1UL])
    {
      i.tx_hash_value.capacity (i.tx_hash_size);
      grew = true;
    }

    // merkleblock_id
    //
    t[2UL] = false;

    // blockheader_id
    //
    t[3UL] = false;

    // block_hash
    //
    if (t[4UL])
    {
      i.block_hash_value.capacity (i.block_hash_size);
      grew = true;
    }

    // block_height
    //
    t[5UL] = false;

    return grew;
  }

  void access::view_traits_impl< ::CoinDB::ConfirmedTxView, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i)
  {
    using namespace sqlite;

    sqlite::statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    std::size_t n (0);

    // tx_id
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.tx_id_value;
    b[n].is_null = &i.tx_id_null;
    n++;

    // tx_hash
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.tx_hash_value.data ();
    b[n].size = &i.tx_hash_size;
    b[n].capacity = i.tx_hash_value.capacity ();
    b[n].is_null = &i.tx_hash_null;
    n++;

    // merkleblock_id
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.merkleblock_id_value;
    b[n].is_null = &i.merkleblock_id_null;
    n++;

    // blockheader_id
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.blockheader_id_value;
    b[n].is_null = &i.blockheader_id_null;
    n++;

    // block_hash
    //
    b[n].type = sqlite::bind::blob;
    b[n].buffer = i.block_hash_value.data ();
    b[n].size = &i.block_hash_size;
    b[n].capacity = i.block_hash_value.capacity ();
    b[n].is_null = &i.block_hash_null;
    n++;

    // block_height
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.block_height_value;
    b[n].is_null = &i.block_height_null;
    n++;
  }

  void access::view_traits_impl< ::CoinDB::ConfirmedTxView, id_sqlite >::
  init (view_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // tx_id
    //
    {
      long unsigned int& v =
        o.tx_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.tx_id_value,
        i.tx_id_null);
    }

    // tx_hash
    //
    {
      ::bytes_t& v =
        o.tx_hash;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.tx_hash_value,
        i.tx_hash_size,
        i.tx_hash_null);
    }

    // merkleblock_id
    //
    {
      long unsigned int& v =
        o.merkleblock_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.merkleblock_id_value,
        i.merkleblock_id_null);
    }

    // blockheader_id
    //
    {
      long unsigned int& v =
        o.blockheader_id;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.blockheader_id_value,
        i.blockheader_id_null);
    }

    // block_hash
    //
    {
      ::bytes_t& v =
        o.block_hash;

      sqlite::value_traits<
          ::bytes_t,
          sqlite::id_blob >::set_value (
        v,
        i.block_hash_value,
        i.block_hash_size,
        i.block_hash_null);
    }

    // block_height
    //
    {
      ::uint32_t& v =
        o.block_height;

      sqlite::value_traits<
          ::uint32_t,
          sqlite::id_integer >::set_value (
        v,
        i.block_height_value,
        i.block_height_null);
    }
  }

  access::view_traits_impl< ::CoinDB::ConfirmedTxView, id_sqlite >::query_base_type
  access::view_traits_impl< ::CoinDB::ConfirmedTxView, id_sqlite >::
  query_statement (const query_base_type& q)
  {
    query_base_type r (
      "SELECT "
      "\"Tx\".\"id\", "
      "\"Tx\".\"hash\", "
      "\"MerkleBlock\".\"id\", "
      "\"BlockHeader\".\"id\", "
      "\"BlockHeader\".\"hash\", "
      "\"BlockHeader\".\"height\" ");

    r += "FROM \"Tx\"";

    r += " LEFT JOIN \"MerkleBlock_hashes\" AS \"t\" ON";
    // From Schema.h:1881:5
    r += "t.value = " + query_columns::Tx::hash;

    r += " LEFT JOIN \"MerkleBlock\" ON";
    // From Schema.h:1882:5
    r += "t.object_id = " + query_columns::MerkleBlock::id;

    r += " LEFT JOIN \"BlockHeader\" ON";
    r += "\"MerkleBlock\".\"blockheader\"=\"BlockHeader\".\"id\"";

    if (!q.empty ())
    {
      r += " ";
      r += q.clause_prefix ();
      r += q;
    }

    return r;
  }

  result< access::view_traits_impl< ::CoinDB::ConfirmedTxView, id_sqlite >::view_type >
  access::view_traits_impl< ::CoinDB::ConfirmedTxView, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    const query_base_type& qs (query_statement (q));
    qs.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        qs.clause (),
        false,
        true,
        qs.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::view_result_impl<view_type> > r (
      new (shared) sqlite::view_result_impl<view_type> (
        qs, st, sts, 0));

    return result<view_type> (r);
  }

  // IncompleteBlockCountView
  //

  bool access::view_traits_impl< ::CoinDB::IncompleteBlockCountView, id_sqlite >::
  grow (image_type& i,
        bool* t)
  {
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (t);

    bool grew (false);

    // count
    //
    t[0UL] = false;

    return grew;
  }

  void access::view_traits_impl< ::CoinDB::IncompleteBlockCountView, id_sqlite >::
  bind (sqlite::bind* b,
        image_type& i)
  {
    using namespace sqlite;

    sqlite::statement_kind sk (statement_select);
    ODB_POTENTIALLY_UNUSED (sk);

    std::size_t n (0);

    // count
    //
    b[n].type = sqlite::bind::integer;
    b[n].buffer = &i.count_value;
    b[n].is_null = &i.count_null;
    n++;
  }

  void access::view_traits_impl< ::CoinDB::IncompleteBlockCountView, id_sqlite >::
  init (view_type& o,
        const image_type& i,
        database* db)
  {
    ODB_POTENTIALLY_UNUSED (o);
    ODB_POTENTIALLY_UNUSED (i);
    ODB_POTENTIALLY_UNUSED (db);

    // count
    //
    {
      long unsigned int& v =
        o.count;

      sqlite::value_traits<
          long unsigned int,
          sqlite::id_integer >::set_value (
        v,
        i.count_value,
        i.count_null);
    }
  }

  access::view_traits_impl< ::CoinDB::IncompleteBlockCountView, id_sqlite >::query_base_type
  access::view_traits_impl< ::CoinDB::IncompleteBlockCountView, id_sqlite >::
  query_statement (const query_base_type& q)
  {
    query_base_type r (
      "SELECT "
      "count(\"MerkleBlock\".\"id\") ");

    r += "FROM \"MerkleBlock\"";

    query_base_type c (
      // From Schema.h:1906:25
      query_columns::txsinserted == false);

    c += q;

    if (!c.empty ())
    {
      r += " ";
      r += c.clause_prefix ();
      r += c;
    }

    return r;
  }

  result< access::view_traits_impl< ::CoinDB::IncompleteBlockCountView, id_sqlite >::view_type >
  access::view_traits_impl< ::CoinDB::IncompleteBlockCountView, id_sqlite >::
  query (database&, const query_base_type& q)
  {
    using namespace sqlite;
    using odb::details::shared;
    using odb::details::shared_ptr;

    sqlite::connection& conn (
      sqlite::transaction::current ().connection ());
    statements_type& sts (
      conn.statement_cache ().find_view<view_type> ());

    image_type& im (sts.image ());
    binding& imb (sts.image_binding ());

    if (im.version != sts.image_version () || imb.version == 0)
    {
      bind (imb.bind, im);
      sts.image_version (im.version);
      imb.version++;
    }

    const query_base_type& qs (query_statement (q));
    qs.init_parameters ();
    shared_ptr<select_statement> st (
      new (shared) select_statement (
        conn,
        qs.clause (),
        false,
        true,
        qs.parameters_binding (),
        imb));

    st->execute ();

    shared_ptr< odb::view_result_impl<view_type> > r (
      new (shared) sqlite::view_result_impl<view_type> (
        qs, st, sts, 0));

    return result<view_type> (r);
  }
}

namespace odb
{
  static bool
  create_schema (database& db, unsigned short pass, bool drop)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (drop);

    if (drop)
    {
      switch (pass)
      {
        case 1:
        {
          return true;
        }
        case 2:
        {
          db.execute ("DROP TABLE IF EXISTS \"Tx\"");
          db.execute ("DROP TABLE IF EXISTS \"TxOut\"");
          db.execute ("DROP TABLE IF EXISTS \"TxIn\"");
          db.execute ("DROP TABLE IF EXISTS \"MerkleBlock_hashes\"");
          db.execute ("DROP TABLE IF EXISTS \"MerkleBlock\"");
          db.execute ("DROP TABLE IF EXISTS \"BlockHeader\"");
          db.execute ("DROP TABLE IF EXISTS \"SigningScript_keys\"");
          db.execute ("DROP TABLE IF EXISTS \"SigningScript\"");
          db.execute ("DROP TABLE IF EXISTS \"Account_keychains\"");
          db.execute ("DROP TABLE IF EXISTS \"Account\"");
          db.execute ("DROP TABLE IF EXISTS \"AccountBin_keychains\"");
          db.execute ("DROP TABLE IF EXISTS \"AccountBin_script_label_map\"");
          db.execute ("DROP TABLE IF EXISTS \"AccountBin\"");
          db.execute ("DROP TABLE IF EXISTS \"Key_derivation_path\"");
          db.execute ("DROP TABLE IF EXISTS \"Key\"");
          db.execute ("DROP TABLE IF EXISTS \"Keychain_derivation_path\"");
          db.execute ("DROP TABLE IF EXISTS \"Keychain\"");
          db.execute ("DROP TABLE IF EXISTS \"Contact\"");
          db.execute ("DROP TABLE IF EXISTS \"User_txoutscript_whitelist\"");
          db.execute ("DROP TABLE IF EXISTS \"User\"");
          db.execute ("DROP TABLE IF EXISTS \"Network\"");
          db.execute ("DROP TABLE IF EXISTS \"Version\"");
          db.execute ("CREATE TABLE IF NOT EXISTS \"schema_version\" (\n"
                      "  \"name\" TEXT NOT NULL PRIMARY KEY,\n"
                      "  \"version\" INTEGER NOT NULL,\n"
                      "  \"migration\" INTEGER NOT NULL)");
          db.execute ("DELETE FROM \"schema_version\"\n"
                      "  WHERE \"name\" = ''");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Version\" (\n"
                      "  \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"version\" INTEGER NOT NULL)");
          db.execute ("CREATE TABLE \"Network\" (\n"
                      "  \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"network\" TEXT NOT NULL)");
          db.execute ("CREATE TABLE \"User\" (\n"
                      "  \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"username\" TEXT NOT NULL,\n"
                      "  \"txoutscript_whitelist_enabled\" INTEGER NOT NULL)");
          db.execute ("CREATE UNIQUE INDEX \"User_username_i\"\n"
                      "  ON \"User\" (\"username\")");
          db.execute ("CREATE TABLE \"User_txoutscript_whitelist\" (\n"
                      "  \"object_id\" INTEGER NOT NULL,\n"
                      "  \"value\" BLOB NOT NULL,\n"
                      "  CONSTRAINT \"object_id_fk\"\n"
                      "    FOREIGN KEY (\"object_id\")\n"
                      "    REFERENCES \"User\" (\"id\")\n"
                      "    ON DELETE CASCADE)");
          db.execute ("CREATE INDEX \"User_txoutscript_whitelist_object_id_i\"\n"
                      "  ON \"User_txoutscript_whitelist\" (\"object_id\")");
          db.execute ("CREATE TABLE \"Contact\" (\n"
                      "  \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"username\" TEXT NOT NULL)");
          db.execute ("CREATE UNIQUE INDEX \"Contact_username_i\"\n"
                      "  ON \"Contact\" (\"username\")");
          db.execute ("CREATE TABLE \"Keychain\" (\n"
                      "  \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"name\" TEXT NOT NULL,\n"
                      "  \"depth\" INTEGER NOT NULL,\n"
                      "  \"parent_fp\" INTEGER NOT NULL,\n"
                      "  \"child_num\" INTEGER NOT NULL,\n"
                      "  \"pubkey\" BLOB NOT NULL,\n"
                      "  \"chain_code\" BLOB NOT NULL,\n"
                      "  \"privkey_ciphertext\" BLOB NOT NULL,\n"
                      "  \"privkey_salt\" INTEGER NOT NULL,\n"
                      "  \"seed_ciphertext\" BLOB NOT NULL,\n"
                      "  \"seed_salt\" INTEGER NOT NULL,\n"
                      "  \"parent\" INTEGER NULL,\n"
                      "  \"hash\" BLOB NOT NULL,\n"
                      "  \"hidden\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"parent_fk\"\n"
                      "    FOREIGN KEY (\"parent\")\n"
                      "    REFERENCES \"Keychain\" (\"id\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE UNIQUE INDEX \"Keychain_name_i\"\n"
                      "  ON \"Keychain\" (\"name\")");
          db.execute ("CREATE TABLE \"Keychain_derivation_path\" (\n"
                      "  \"object_id\" INTEGER NOT NULL,\n"
                      "  \"index\" INTEGER NOT NULL,\n"
                      "  \"value\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"object_id_fk\"\n"
                      "    FOREIGN KEY (\"object_id\")\n"
                      "    REFERENCES \"Keychain\" (\"id\")\n"
                      "    ON DELETE CASCADE)");
          db.execute ("CREATE INDEX \"Keychain_derivation_path_object_id_i\"\n"
                      "  ON \"Keychain_derivation_path\" (\"object_id\")");
          db.execute ("CREATE INDEX \"Keychain_derivation_path_index_i\"\n"
                      "  ON \"Keychain_derivation_path\" (\"index\")");
          db.execute ("CREATE TABLE \"Key\" (\n"
                      "  \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"root_keychain\" INTEGER NULL,\n"
                      "  \"index\" INTEGER NOT NULL,\n"
                      "  \"pubkey\" BLOB NOT NULL,\n"
                      "  \"is_private\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"root_keychain_fk\"\n"
                      "    FOREIGN KEY (\"root_keychain\")\n"
                      "    REFERENCES \"Keychain\" (\"id\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE TABLE \"Key_derivation_path\" (\n"
                      "  \"object_id\" INTEGER NOT NULL,\n"
                      "  \"index\" INTEGER NOT NULL,\n"
                      "  \"value\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"object_id_fk\"\n"
                      "    FOREIGN KEY (\"object_id\")\n"
                      "    REFERENCES \"Key\" (\"id\")\n"
                      "    ON DELETE CASCADE)");
          db.execute ("CREATE INDEX \"Key_derivation_path_object_id_i\"\n"
                      "  ON \"Key_derivation_path\" (\"object_id\")");
          db.execute ("CREATE INDEX \"Key_derivation_path_index_i\"\n"
                      "  ON \"Key_derivation_path\" (\"index\")");
          db.execute ("CREATE TABLE \"AccountBin\" (\n"
                      "  \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"account\" INTEGER NULL,\n"
                      "  \"index\" INTEGER NOT NULL,\n"
                      "  \"name\" TEXT NOT NULL,\n"
                      "  \"script_count\" INTEGER NOT NULL,\n"
                      "  \"next_script_index\" INTEGER NOT NULL,\n"
                      "  \"minsigs\" INTEGER NOT NULL,\n"
                      "  \"hash\" BLOB NOT NULL,\n"
                      "  CONSTRAINT \"account_fk\"\n"
                      "    FOREIGN KEY (\"account\")\n"
                      "    REFERENCES \"Account\" (\"id\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE UNIQUE INDEX \"AccountBin_hash_i\"\n"
                      "  ON \"AccountBin\" (\"hash\")");
          db.execute ("CREATE TABLE \"AccountBin_script_label_map\" (\n"
                      "  \"object_id\" INTEGER NOT NULL,\n"
                      "  \"key\" INTEGER NOT NULL,\n"
                      "  \"value\" TEXT NOT NULL,\n"
                      "  CONSTRAINT \"object_id_fk\"\n"
                      "    FOREIGN KEY (\"object_id\")\n"
                      "    REFERENCES \"AccountBin\" (\"id\")\n"
                      "    ON DELETE CASCADE)");
          db.execute ("CREATE INDEX \"AccountBin_script_label_map_object_id_i\"\n"
                      "  ON \"AccountBin_script_label_map\" (\"object_id\")");
          db.execute ("CREATE TABLE \"AccountBin_keychains\" (\n"
                      "  \"object_id\" INTEGER NOT NULL,\n"
                      "  \"value\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"object_id_fk\"\n"
                      "    FOREIGN KEY (\"object_id\")\n"
                      "    REFERENCES \"AccountBin\" (\"id\")\n"
                      "    ON DELETE CASCADE,\n"
                      "  CONSTRAINT \"value_fk\"\n"
                      "    FOREIGN KEY (\"value\")\n"
                      "    REFERENCES \"Keychain\" (\"id\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE INDEX \"AccountBin_keychains_object_id_i\"\n"
                      "  ON \"AccountBin_keychains\" (\"object_id\")");
          db.execute ("CREATE TABLE \"Account\" (\n"
                      "  \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"name\" TEXT NOT NULL,\n"
                      "  \"minsigs\" INTEGER NOT NULL,\n"
                      "  \"unused_pool_size\" INTEGER NOT NULL,\n"
                      "  \"time_created\" INTEGER NOT NULL,\n"
                      "  \"hash\" BLOB NOT NULL,\n"
                      "  \"compressed_keys\" INTEGER NOT NULL)");
          db.execute ("CREATE UNIQUE INDEX \"Account_name_i\"\n"
                      "  ON \"Account\" (\"name\")");
          db.execute ("CREATE UNIQUE INDEX \"Account_hash_i\"\n"
                      "  ON \"Account\" (\"hash\")");
          db.execute ("CREATE TABLE \"Account_keychains\" (\n"
                      "  \"object_id\" INTEGER NOT NULL,\n"
                      "  \"value\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"object_id_fk\"\n"
                      "    FOREIGN KEY (\"object_id\")\n"
                      "    REFERENCES \"Account\" (\"id\")\n"
                      "    ON DELETE CASCADE,\n"
                      "  CONSTRAINT \"value_fk\"\n"
                      "    FOREIGN KEY (\"value\")\n"
                      "    REFERENCES \"Keychain\" (\"id\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE INDEX \"Account_keychains_object_id_i\"\n"
                      "  ON \"Account_keychains\" (\"object_id\")");
          db.execute ("CREATE TABLE \"SigningScript\" (\n"
                      "  \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"account\" INTEGER NULL,\n"
                      "  \"account_bin\" INTEGER NULL,\n"
                      "  \"index\" INTEGER NOT NULL,\n"
                      "  \"label\" TEXT NOT NULL,\n"
                      "  \"status\" INTEGER NOT NULL,\n"
                      "  \"txinscript\" BLOB NOT NULL,\n"
                      "  \"txoutscript\" BLOB NOT NULL,\n"
                      "  \"contact\" INTEGER NULL,\n"
                      "  CONSTRAINT \"account_fk\"\n"
                      "    FOREIGN KEY (\"account\")\n"
                      "    REFERENCES \"Account\" (\"id\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"account_bin_fk\"\n"
                      "    FOREIGN KEY (\"account_bin\")\n"
                      "    REFERENCES \"AccountBin\" (\"id\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"contact_fk\"\n"
                      "    FOREIGN KEY (\"contact\")\n"
                      "    REFERENCES \"Contact\" (\"id\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE TABLE \"SigningScript_keys\" (\n"
                      "  \"object_id\" INTEGER NOT NULL,\n"
                      "  \"index\" INTEGER NOT NULL,\n"
                      "  \"value\" INTEGER NULL,\n"
                      "  CONSTRAINT \"object_id_fk\"\n"
                      "    FOREIGN KEY (\"object_id\")\n"
                      "    REFERENCES \"SigningScript\" (\"id\")\n"
                      "    ON DELETE CASCADE,\n"
                      "  CONSTRAINT \"value_fk\"\n"
                      "    FOREIGN KEY (\"value\")\n"
                      "    REFERENCES \"Key\" (\"id\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE INDEX \"SigningScript_keys_object_id_i\"\n"
                      "  ON \"SigningScript_keys\" (\"object_id\")");
          db.execute ("CREATE INDEX \"SigningScript_keys_index_i\"\n"
                      "  ON \"SigningScript_keys\" (\"index\")");
          db.execute ("CREATE TABLE \"BlockHeader\" (\n"
                      "  \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"hash\" BLOB NOT NULL,\n"
                      "  \"height\" INTEGER NOT NULL,\n"
                      "  \"version\" INTEGER NOT NULL,\n"
                      "  \"prevhash\" BLOB NOT NULL,\n"
                      "  \"merkleroot\" BLOB NOT NULL,\n"
                      "  \"timestamp\" INTEGER NOT NULL,\n"
                      "  \"bits\" INTEGER NOT NULL,\n"
                      "  \"nonce\" INTEGER NOT NULL)");
          db.execute ("CREATE UNIQUE INDEX \"BlockHeader_hash_i\"\n"
                      "  ON \"BlockHeader\" (\"hash\")");
          db.execute ("CREATE UNIQUE INDEX \"BlockHeader_height_i\"\n"
                      "  ON \"BlockHeader\" (\"height\")");
          db.execute ("CREATE TABLE \"MerkleBlock\" (\n"
                      "  \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"blockheader\" INTEGER NOT NULL,\n"
                      "  \"txcount\" INTEGER NOT NULL,\n"
                      "  \"flags\" BLOB NOT NULL,\n"
                      "  \"txsinserted\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"blockheader_fk\"\n"
                      "    FOREIGN KEY (\"blockheader\")\n"
                      "    REFERENCES \"BlockHeader\" (\"id\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE TABLE \"MerkleBlock_hashes\" (\n"
                      "  \"object_id\" INTEGER NOT NULL,\n"
                      "  \"index\" INTEGER NOT NULL,\n"
                      "  \"value\" BLOB NOT NULL,\n"
                      "  CONSTRAINT \"object_id_fk\"\n"
                      "    FOREIGN KEY (\"object_id\")\n"
                      "    REFERENCES \"MerkleBlock\" (\"id\")\n"
                      "    ON DELETE CASCADE)");
          db.execute ("CREATE INDEX \"MerkleBlock_hashes_object_id_i\"\n"
                      "  ON \"MerkleBlock_hashes\" (\"object_id\")");
          db.execute ("CREATE INDEX \"MerkleBlock_hashes_index_i\"\n"
                      "  ON \"MerkleBlock_hashes\" (\"index\")");
          db.execute ("CREATE TABLE \"TxIn\" (\n"
                      "  \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"outhash\" BLOB NOT NULL,\n"
                      "  \"outindex\" INTEGER NOT NULL,\n"
                      "  \"script\" BLOB NOT NULL,\n"
                      "  \"sequence\" INTEGER NOT NULL,\n"
                      "  \"tx\" INTEGER NOT NULL,\n"
                      "  \"txindex\" INTEGER NOT NULL,\n"
                      "  \"outpoint\" INTEGER NULL,\n"
                      "  CONSTRAINT \"tx_fk\"\n"
                      "    FOREIGN KEY (\"tx\")\n"
                      "    REFERENCES \"Tx\" (\"id\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"outpoint_fk\"\n"
                      "    FOREIGN KEY (\"outpoint\")\n"
                      "    REFERENCES \"TxOut\" (\"id\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE TABLE \"TxOut\" (\n"
                      "  \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"value\" INTEGER NOT NULL,\n"
                      "  \"script\" BLOB NOT NULL,\n"
                      "  \"tx\" INTEGER NOT NULL,\n"
                      "  \"txindex\" INTEGER NOT NULL,\n"
                      "  \"spent\" INTEGER NULL,\n"
                      "  \"sending_account\" INTEGER NULL,\n"
                      "  \"sending_label\" TEXT NOT NULL,\n"
                      "  \"receiving_account\" INTEGER NULL,\n"
                      "  \"receiving_label\" TEXT NOT NULL,\n"
                      "  \"account_bin\" INTEGER NULL,\n"
                      "  \"signingscript\" INTEGER NULL,\n"
                      "  \"status\" INTEGER NOT NULL,\n"
                      "  CONSTRAINT \"tx_fk\"\n"
                      "    FOREIGN KEY (\"tx\")\n"
                      "    REFERENCES \"Tx\" (\"id\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"spent_fk\"\n"
                      "    FOREIGN KEY (\"spent\")\n"
                      "    REFERENCES \"TxIn\" (\"id\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"sending_account_fk\"\n"
                      "    FOREIGN KEY (\"sending_account\")\n"
                      "    REFERENCES \"Account\" (\"id\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"receiving_account_fk\"\n"
                      "    FOREIGN KEY (\"receiving_account\")\n"
                      "    REFERENCES \"Account\" (\"id\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"account_bin_fk\"\n"
                      "    FOREIGN KEY (\"account_bin\")\n"
                      "    REFERENCES \"AccountBin\" (\"id\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"signingscript_fk\"\n"
                      "    FOREIGN KEY (\"signingscript\")\n"
                      "    REFERENCES \"SigningScript\" (\"id\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE TABLE \"Tx\" (\n"
                      "  \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"hash\" BLOB NOT NULL,\n"
                      "  \"unsigned_hash\" BLOB NOT NULL,\n"
                      "  \"version\" INTEGER NOT NULL,\n"
                      "  \"locktime\" INTEGER NOT NULL,\n"
                      "  \"timestamp\" INTEGER NOT NULL,\n"
                      "  \"status\" INTEGER NOT NULL,\n"
                      "  \"conflicting\" INTEGER NOT NULL,\n"
                      "  \"have_all_outpoints\" INTEGER NOT NULL,\n"
                      "  \"txin_total\" INTEGER NOT NULL,\n"
                      "  \"txout_total\" INTEGER NOT NULL,\n"
                      "  \"blockheader\" INTEGER NULL,\n"
                      "  \"blockindex\" INTEGER NULL,\n"
                      "  \"user\" INTEGER NULL,\n"
                      "  \"propagation_protocol\" TEXT NOT NULL,\n"
                      "  CONSTRAINT \"blockheader_fk\"\n"
                      "    FOREIGN KEY (\"blockheader\")\n"
                      "    REFERENCES \"BlockHeader\" (\"id\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED,\n"
                      "  CONSTRAINT \"user_fk\"\n"
                      "    FOREIGN KEY (\"user\")\n"
                      "    REFERENCES \"User\" (\"id\")\n"
                      "    DEFERRABLE INITIALLY DEFERRED)");
          db.execute ("CREATE UNIQUE INDEX \"Tx_unsigned_hash_i\"\n"
                      "  ON \"Tx\" (\"unsigned_hash\")");
          return true;
        }
        case 2:
        {
          db.execute ("CREATE TABLE IF NOT EXISTS \"schema_version\" (\n"
                      "  \"name\" TEXT NOT NULL PRIMARY KEY,\n"
                      "  \"version\" INTEGER NOT NULL,\n"
                      "  \"migration\" INTEGER NOT NULL)");
          db.execute ("INSERT OR IGNORE INTO \"schema_version\" (\n"
                      "  \"name\", \"version\", \"migration\")\n"
                      "  VALUES ('', 17, 0)");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_create_entry
  create_schema_entry_ (
    id_sqlite,
    "",
    &create_schema);

  static const schema_catalog_migrate_entry
  migrate_schema_entry_12_ (
    id_sqlite,
    "",
    12ULL,
    0);

  static bool
  migrate_schema_13 (database& db, unsigned short pass, bool pre)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (pre);

    if (pre)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"Contact\" (\n"
                      "  \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"username\" TEXT NOT NULL)");
          db.execute ("CREATE UNIQUE INDEX \"Contact_username_i\"\n"
                      "  ON \"Contact\" (\"username\")");
          db.execute ("ALTER TABLE \"SigningScript\"\n"
                      "  ADD COLUMN \"contact\" INTEGER NULL CONSTRAINT \"contact_fk\" REFERENCES \"Contact\" (\"id\")");
          return true;
        }
        case 2:
        {
          db.execute ("UPDATE \"schema_version\"\n"
                      "  SET \"version\" = 13, \"migration\" = 1\n"
                      "  WHERE \"name\" = ''");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          return true;
        }
        case 2:
        {
          db.execute ("UPDATE \"schema_version\"\n"
                      "  SET \"migration\" = 0\n"
                      "  WHERE \"name\" = ''");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_migrate_entry
  migrate_schema_entry_13_ (
    id_sqlite,
    "",
    13ULL,
    &migrate_schema_13);

  static bool
  migrate_schema_14 (database& db, unsigned short pass, bool pre)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (pre);

    if (pre)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("ALTER TABLE \"Account\"\n"
                      "  ADD COLUMN \"compressed_keys\" INTEGER NULL");
          return true;
        }
        case 2:
        {
          db.execute ("UPDATE \"schema_version\"\n"
                      "  SET \"version\" = 14, \"migration\" = 1\n"
                      "  WHERE \"name\" = ''");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          return true;
        }
        case 2:
        {
          db.execute ("UPDATE \"schema_version\"\n"
                      "  SET \"migration\" = 0\n"
                      "  WHERE \"name\" = ''");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_migrate_entry
  migrate_schema_entry_14_ (
    id_sqlite,
    "",
    14ULL,
    &migrate_schema_14);

  static bool
  migrate_schema_15 (database& db, unsigned short pass, bool pre)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (pre);

    if (pre)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("CREATE TABLE \"User\" (\n"
                      "  \"id\" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n"
                      "  \"username\" TEXT NOT NULL,\n"
                      "  \"txoutscript_whitelist_enabled\" INTEGER NOT NULL)");
          db.execute ("CREATE UNIQUE INDEX \"User_username_i\"\n"
                      "  ON \"User\" (\"username\")");
          db.execute ("CREATE TABLE \"User_txoutscript_whitelist\" (\n"
                      "  \"object_id\" INTEGER NOT NULL,\n"
                      "  \"value\" BLOB NOT NULL,\n"
                      "  CONSTRAINT \"object_id_fk\"\n"
                      "    FOREIGN KEY (\"object_id\")\n"
                      "    REFERENCES \"User\" (\"id\")\n"
                      "    ON DELETE CASCADE)");
          db.execute ("CREATE INDEX \"User_txoutscript_whitelist_object_id_i\"\n"
                      "  ON \"User_txoutscript_whitelist\" (\"object_id\")");
          db.execute ("ALTER TABLE \"Tx\"\n"
                      "  ADD COLUMN \"user\" INTEGER NULL CONSTRAINT \"user_fk\" REFERENCES \"User\" (\"id\")");
          return true;
        }
        case 2:
        {
          db.execute ("UPDATE \"schema_version\"\n"
                      "  SET \"version\" = 15, \"migration\" = 1\n"
                      "  WHERE \"name\" = ''");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          return true;
        }
        case 2:
        {
          db.execute ("UPDATE \"schema_version\"\n"
                      "  SET \"migration\" = 0\n"
                      "  WHERE \"name\" = ''");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_migrate_entry
  migrate_schema_entry_15_ (
    id_sqlite,
    "",
    15ULL,
    &migrate_schema_15);

  static bool
  migrate_schema_16 (database& db, unsigned short pass, bool pre)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (pre);

    if (pre)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("ALTER TABLE \"Keychain\"\n"
                      "  ADD COLUMN \"seed_ciphertext\" BLOB NULL");
          db.execute ("ALTER TABLE \"Keychain\"\n"
                      "  ADD COLUMN \"seed_salt\" INTEGER NULL");
          return true;
        }
        case 2:
        {
          db.execute ("UPDATE \"schema_version\"\n"
                      "  SET \"version\" = 16, \"migration\" = 1\n"
                      "  WHERE \"name\" = ''");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          return true;
        }
        case 2:
        {
          db.execute ("UPDATE \"schema_version\"\n"
                      "  SET \"migration\" = 0\n"
                      "  WHERE \"name\" = ''");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_migrate_entry
  migrate_schema_entry_16_ (
    id_sqlite,
    "",
    16ULL,
    &migrate_schema_16);

  static bool
  migrate_schema_17 (database& db, unsigned short pass, bool pre)
  {
    ODB_POTENTIALLY_UNUSED (db);
    ODB_POTENTIALLY_UNUSED (pass);
    ODB_POTENTIALLY_UNUSED (pre);

    if (pre)
    {
      switch (pass)
      {
        case 1:
        {
          db.execute ("ALTER TABLE \"Tx\"\n"
                      "  ADD COLUMN \"propagation_protocol\" TEXT NULL");
          return true;
        }
        case 2:
        {
          db.execute ("UPDATE \"schema_version\"\n"
                      "  SET \"version\" = 17, \"migration\" = 1\n"
                      "  WHERE \"name\" = ''");
          return false;
        }
      }
    }
    else
    {
      switch (pass)
      {
        case 1:
        {
          return true;
        }
        case 2:
        {
          db.execute ("UPDATE \"schema_version\"\n"
                      "  SET \"migration\" = 0\n"
                      "  WHERE \"name\" = ''");
          return false;
        }
      }
    }

    return false;
  }

  static const schema_catalog_migrate_entry
  migrate_schema_entry_17_ (
    id_sqlite,
    "",
    17ULL,
    &migrate_schema_17);
}

#include <odb/post.hxx>
